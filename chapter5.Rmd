---
title_meta: Capítulo 5
title: Marcos de datos
description: >-
  La mayoría de los conjuntos de datos con los que trabajarás se almacenarán
  como marcos de datos. Al final de este capítulo, serás capaz de crear un marco
  de datos, seleccionar partes interesantes de un marco de datos y ordenar un
  marco de datos según determinadas variables.
---

## ¿Qué es un marco de datos?

```yaml
type: NormalExercise
key: 7f95849020a2563168920409022ce7bed20835b5
xp: 100
skills:
  - 1
```

Quizá recuerdes del capítulo sobre matrices que todos los elementos que pongas en una matriz deben ser del mismo tipo. Por aquel entonces, tu conjunto de datos sobre La Guerra de las Galaxias solo contenía elementos numéricos. 

Sin embargo, cuando realizas una encuesta de investigación de mercado, a menudo te surgen preguntas como las siguientes:

- Preguntas del tipo "¿estás casado?" o "sí/no" (`logical`)
- ¿Cuántos años tienes?" (`numeric`)
- "¿Cuál es tu opinión sobre este producto?" u otras preguntas "abiertas" (`character`)
- ...

El resultado, es decir, las respuestas de los encuestados a las preguntas formuladas anteriormente, es un conjunto de datos de distintos tipos. A menudo te encontrarás trabajando con conjuntos de datos que contienen distintos tipos de datos en lugar de uno solo. 

Un marco de datos tiene las variables de un conjunto de datos como columnas y las observaciones como filas. Éste será un concepto familiar para quienes procedan de distintos paquetes de software estadístico, como SAS o SPSS.

`@instructions`
Envía la respuesta. Los datos del marco de datos de ejemplo incorporado `mtcars` se imprimirán en la consola.

`@hint`
¡Envía la respuesta y sé testigo de la magia!

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Print out built-in R data frame
mtcars 
```

`@solution`
```{r}
# Print out built-in R data frame
mtcars 
```

`@sct`
```{r}
ex() %>% check_output_expr("mtcars", missing_msg = "No cambies nada del código, asegúrate de que imprimes `mtcars`.")

success_msg("¡Genial! Continúa con el siguiente ejercicio.")
```

---

## Rápido, echa un vistazo a tu conjunto de datos

```yaml
type: NormalExercise
key: 3d0e64ecf5f69521ee538ecc713caa02b8b0ec46
xp: 100
skills:
  - 1
```

Vaya, ¡son muchos coches! 

Trabajar con grandes conjuntos de datos suele ser frecuente en el análisis de datos. Cuando trabajas con conjuntos de datos y marcos de datos (extremadamente) grandes, tu primera tarea como analista de datos es desarrollar una comprensión clara de su estructura y elementos principales. Por eso, a menudo es útil mostrar solo una pequeña parte de todo el conjunto de datos. 

¿Cómo hacerlo en R? Pues bien, la función `head()` te permite mostrar las primeras observaciones de un marco de datos. Del mismo modo, la función `tail()` imprime las últimas observaciones de tu conjunto de datos.

Tanto `head()` como `tail()` imprimen una línea superior llamada "cabecera", que contiene los nombres de las distintas variables de tu conjunto de datos.

`@instructions`
Llama a `head()` en el conjunto de datos `mtcars` para echar un vistazo a la cabecera y a las primeras observaciones.

`@hint`
`head(mtcars)` mostrará las primeras observaciones del marco de datos `mtcars`.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Call head() on mtcars

```

`@solution`
```{r}
# Call head() on mtcars
head(mtcars)
```

`@sct`
```{r}
ex() %>% check_function("head") %>% check_arg('x') %>% check_equal(incorrect_msg = "¿Has pasado correctamente `mtcars` a la función `head()`?")

ex() %>% check_output_expr("head(mtcars)", missing_msg = "Simplemente imprime el resultado de la llamada a `head()`, no es necesario asignarlo a una nueva variable.")

success_msg("¡Maravilloso! Entonces, ¿qué tenemos en este conjunto de datos? Por ejemplo, `hp` representa la potencia del coche; el Datsun tiene la menor potencia de los 6 coches que se muestran. Para una visión completa del significado de las variables, escribe `?mtcars` en la consola y lee la página de ayuda. ¡Continúa con el siguiente ejercicio!");
```

---

## Echa un vistazo a la estructura

```yaml
type: NormalExercise
key: f4d5b1a2c4aef31645fc7e3505e699fb6e48f3e6
xp: 100
skills:
  - 1
```

Otro método que se utiliza a menudo para obtener una visión rápida de tus datos es la función `str()`. La función `str()` te muestra la estructura de tu conjunto de datos. En un marco de datos te dice:

- El número total de observaciones (por ejemplo, 32 tipos de coches)
- El número total de variables (por ejemplo, 11 características del coche)
- Una lista completa de los nombres de las variables (por ejemplo: `mpg`, `cyl`... )
- El tipo de datos de cada variable (por ejemplo `num`)
- Las primeras observaciones

Aplicar la función `str()`] será a menudo lo primero que hagas al recibir un nuevo conjunto de datos o marco de datos. Es una forma estupenda de conocer mejor tu conjunto de datos antes de sumergirte en el análisis real.

`@instructions`
Investiga la estructura de `mtcars`. Asegúrate de que ves los mismos números, variables y tipos de datos que se han mencionado anteriormente.

`@hint`
Utiliza la función `str()` en `mtcars`.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Investigate the structure of mtcars

```

`@solution`
```{r}
# Investigate the structure of mtcars
str(mtcars)
```

`@sct`
```{r}
ex() %>% check_output_expr("str(mtcars)", missing_msg = "¿Has llamado correctamente a `str()` en `mtcars`?")

success_msg("¡Buen trabajo! Puedes encontrar mucha información viendo el `str()` de un conjunto de datos. Continúa con el siguiente ejercicio.")
```

---

## Crear un marco de datos

```yaml
type: NormalExercise
key: df0b89706d90526b3c0bbe15e400b74cbd900704
xp: 100
skills:
  - 1
```

Puesto que utilizar los conjuntos de datos incorporados no es ni la mitad de divertido que crear tus propios conjuntos de datos, el resto de este capítulo se basa en tu conjunto de datos desarrollado personalmente. Ponte la mochila propulsora porque ha llegado la hora de explorar el espacio. 

Como primer objetivo, quieres construir un marco de datos que describa las características principales de ocho planetas de nuestro sistema solar. Según tu buen amigo Buzz, las principales características de un planeta son:

- El tipo de planeta (terrestre o gigante gaseoso).
- El diámetro del planeta en relación con el diámetro de la Tierra.
- La rotación del planeta a través del Sol en relación con la de la Tierra.
- Si el planeta tiene anillos o no (TRUE o FALSE).

Tras realizar una investigación de calidad en [Wikipedia](https://en.wikipedia.org/wiki/Planet), te sientes lo suficientemente seguro como para crear los vectores necesarios: `name`, `type`, `diameter`, `rotation` y `rings`; estos vectores ya se han codificado en el editor. El primer elemento de cada uno de estos vectores corresponde a la primera observación.

Construye un marco de datos con la función `data.frame()`. Como argumentos, pasas los vectores de antes: se convertirán en las distintas columnas de tu marco de datos. Como cada columna tiene la misma longitud, los vectores que pases también deben tener la misma longitud. Pero no olvides que es posible (y probable) que contengan distintos tipos de datos.

`@instructions`
Utiliza la función `data.frame()` para construir un marco de datos. Pasa los vectores `name`, `type`, `diameter`, `rotation` y `rings` como argumentos a `data.frame()`, en este orden. Llama al marco de datos resultante `planets_df`.

`@hint`
Tu llamada a `data.frame()` comienza como sigue:
```
data.frame(planets, type, diameter)
```
¿Puedes terminarlo?

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03, 
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <-

```

`@solution`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sct`
```{r}
msg = "No cambies nada sobre la definición de los vectores. Solo agrega una llamada a `data.frame()` para crear `planets_df`."
ex() %>% check_object("name", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("type", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("diameter", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rotation", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rings", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("planets_df") %>% check_equal(incorrect_msg = "¿Has llamado correctamente a `data.frame()` para crear `planets_df`? Dentro de `data.frame()`, asegúrate de pasar todos los vectores en el orden correcto: `name`, `type`, `diameter`, `rotation` y finalmente `rings`.")

success_msg("¡Buen trabajo! El siguiente paso lógico, como ya sabes, es inspeccionar el data frame que acabas de crear. Dirígete al siguiente ejercicio.");
```

---

## Crear un marco de datos (2)

```yaml
type: NormalExercise
key: c13ea421dd078030a225f49e53a8927ce8fefbe0
xp: 100
skills:
  - 1
```

El marco de datos `planets_df` debe tener 8 observaciones y 5 variables. Se ha puesto a tu disposición en el espacio de trabajo, para que puedas utilizarlo directamente.

`@instructions`
Utiliza `str()` para investigar la estructura de la nueva variable `planets_df`.

`@hint`
`planets_df` ya está disponible en tu espacio de trabajo, así que `str(planets_df)` servirá.

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# Check the structure of planets_df
```

`@solution`
```{r}
# Check the structure of planets_df
str(planets_df)
```

`@sct`
```{r}
msg = "¡No elimines ni sobrescribas el marco de datos `planets_df` que ya está disponible en el espacio de trabajo!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr("str(planets_df)", missing_msg = "¿Has mostrado correctamente la estructura de `planets_df`? ¡Usa `str()` para hacerlo!")

success_msg("¡Genial! Ahora que tienes una comprensión clara del conjunto de datos `planets_df`, es hora de ver cómo puedes seleccionar elementos de él. ¡Aprende todo sobre esto en los próximos ejercicios!")
```

---

## Selección de los elementos del marco de datos

```yaml
type: NormalExercise
key: 8c664726b8a173cda730cbb20a52ac1795d9a0e9
xp: 100
skills:
  - 1
```

De forma similar a los vectores y las matrices, puedes seleccionar elementos de un marco de datos con la ayuda de los corchetes `[ ]`. Mediante una coma puedes indicar qué seleccionar de las filas y de las columnas respectivamente. Por ejemplo:

- `my_df[1,2]` selecciona el valor de la primera fila y la segunda columna en `my_df`.
- `my_df[1:3,2:4]` selecciona las filas 1, 2, 3 y las columnas 2, 3, 4 en `my_df`.

A veces quieres seleccionar todos los elementos de una fila o columna. Por ejemplo, `my_df[1, ]` selecciona todos los elementos de la primera fila. ¡Apliquemos ahora esta técnica en `planets_df`!

`@instructions`
- En `planets_df`, selecciona el diámetro de Mercurio: es el valor de la primera fila y la tercera columna. Solo tienes que imprimir el resultado.
- En `planets_df`, selecciona todos los datos de Marte (la cuarta fila). Solo tienes que imprimir el resultado.

`@hint`
Para seleccionar el diámetro de Venus (la segunda fila), necesitarías: `planets_df[2,3]`. ¿Qué necesitas entonces para Mercurio?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Print out diameter of Mercury (row 1, column 3)


# Print out data for Mars (entire fourth row)

```

`@solution`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Print out diameter of Mercury (row 1, column 3)
planets_df[1,3]

# Print out data for Mars (entire fourth row)
planets_df[4, ]
```

`@sct`
```{r}
msg = "¡No elimines ni sobrescribas el data frame `planets_df`!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr("planets_df[1,3]", missing_msg = "¿Has seleccionado e impreso correctamente el diámetro de Mercurio? Puedes usar `[1,3]`.")

ex() %>% check_output_expr("planets_df[4, ]", missing_msg = "¿Has seleccionado e impreso correctamente todos los datos de Marte? Puedes usar `[4,]`.")

success_msg("¡Genial! Además de seleccionar elementos de tu data frame por índice, también puedes usar los nombres de las columnas. Para aprender cómo, dirígete al siguiente ejercicio.")
```

---

## Selección de los elementos del marco de datos (2)

```yaml
type: NormalExercise
key: faf104fb0c605fd89f048648a4a588200bc89c76
xp: 100
skills:
  - 1
```

En lugar de utilizar números para seleccionar elementos de un marco de datos, también puedes utilizar los nombres de las variables para seleccionar columnas de un marco de datos. 

Supongamos que quieres seleccionar los tres primeros elementos de la columna `type`. Una forma de hacerlo es

```
planets_df[1:3,2]
```

Una posible desventaja de este enfoque es que tienes que conocer (o buscar) el número de columna de `type`, lo que se hace difícil si tienes muchas variables. A menudo es más fácil utilizar simplemente el nombre de la variable:

```
planets_df[1:3,"type"]
```

`@instructions`
Selecciona e imprime los 5 primeros valores de la columna `"diameter"` de `planets_df`.

`@hint`
Puedes seleccionar los cinco primeros valores con `planets_df[1:5, ...]`. ¿Puedes rellenar el bit `...` para seleccionar solo la columna `"diameter"`?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Select first 5 values of diameter column

```

`@solution`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Select first 5 values of diameter column
planets_df[1:5, "diameter"]
```

`@sct`
```{r}
msg = "¡No elimines ni sobrescribas el data frame `planets_df`!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr("planets_df[1:5, \"diameter\"]", missing_msg = "¿Has seleccionado correctamente los primeros cinco valores de la columna de diámetro y los has impreso? Puedes usar `[1:5, \"diameter\"]` aquí.")

success_msg("¡Bien hecho! ¡Continúa con el siguiente ejercicio!")
```

---

## Solo planetas con anillos

```yaml
type: NormalExercise
key: e550ecb6ec45b856e6160ddfbb3d7875998e8365
xp: 100
skills:
  - 1
```

A menudo querrás seleccionar una columna entera, es decir, una variable concreta de un marco de datos. Si quieres seleccionar todos los elementos de la variable `diameter`, por ejemplo, ambos te servirán:

```
planets_df[,3]
planets_df[,"diameter"]
```

Sin embargo, existe un atajo. Si tus columnas tienen nombre, puedes utilizar el signo `$`:

```
planets_df$diameter
```

`@instructions`
- Utiliza el signo `$` para seleccionar la variable `rings` de `planets_df`. Guarda el vector resultante como `rings_vector`.
- Imprime `rings_vector` para ver si lo has hecho bien.

`@hint`
`planets_df$diameter` selecciona la columna `diameter` de `planets_df`; ¿qué necesitas entonces para seleccionar la columna `rings`?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# planets_df is pre-loaded in your workspace

# Select the rings variable from planets_df
rings_vector <- 
  
# Print out rings_vector
```

`@solution`
```{r}
# planets_df is pre-loaded in your workspace

# Select the rings variable from planets_df
rings_vector <- planets_df$rings

# Print out rings_vector
rings_vector
```

`@sct`
```{r}
msg = "¡No elimines ni sobrescribas el data frame `planets_df`!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rings_vector") %>% check_equal(incorrect_msg = "¿Has seleccionado correctamente la variable `rings` de `planets_df`? Usa `$rings`. Guarda el resultado como `rings_vector`.")

ex() %>% check_output_expr("rings_vector", missing_msg = "¡No olvides imprimir `rings_vector` después de crearlo!")

success_msg("¡Genial! Continúa con el siguiente ejercicio y descubre otra forma de hacer subsetting.")
```

---

## Solo planetas con anillos (2)

```yaml
type: NormalExercise
key: 1581bf4667477f274188f4f637ec7fdc73659651
xp: 100
skills:
  - 1
```

Probablemente recuerdes del instituto que algunos planetas de nuestro sistema solar tienen anillos y otros no. Por desgracia, no puedes recordar sus nombres. ¿Podría ayudarte R?

Si escribes `rings_vector` en la consola, obtendrás:

```
[1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
```

Esto significa que las cuatro primeras observaciones (o planetas) no tienen anillo (`FALSE`), pero las otras cuatro sí (`TRUE`). Sin embargo, no obtienes una buena visión general de los nombres de estos planetas, su diámetro, etc. Intentemos utilizar `rings_vector` para seleccionar los datos de los cuatro planetas con anillos.

`@instructions`
El código del editor selecciona la columna `name` de todos los planetas que tienen anillos. Adapta el código para que, en lugar de solo la columna `name`, se seleccionen _todas_ las columnas de los planetas que tienen anillos.

`@hint`
Recuerda que para seleccionar _todas las_ columnas, ¡simplemente tienes que dejar vacía la parte de las columnas dentro de `[ ]`! Esto significa que necesitarás `[rings_vector, ]`.

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)

rings_vector <- planets_df$rings
```

`@sample_code`
```{r}
# planets_df and rings_vector are pre-loaded in your workspace

# Adapt the code to select all columns for planets with rings
planets_df[rings_vector, "name"]
```

`@solution`
```{r}
# planets_df and rings_vector are pre-loaded in your workspace

# Adapt the code to select all columns for planets with rings
planets_df[rings_vector, ]
```

`@sct`
```{r}
msg <- "¡No elimines ni sobrescribas `planets_df` o `rings_vector`!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rings_vector", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr('planets_df[rings_vector, ]', missing_msg = "¿Has adaptado correctamente el código para seleccionar _todas_ las columnas de los planetas que tienen anillos? Puedes usar `planets_df[rings_vector, ]`. Asegúrate de incluir la coma aquí, es crucial!")

success_msg("¡Maravilloso! Esta es una solución bastante tediosa. El próximo ejercicio te enseñará cómo hacerlo de una manera más concisa.")
```

---

## Solo planetas con anillos pero más cortos

```yaml
type: NormalExercise
key: a4a8b72a74097196eb2f8a28b056987aae834565
xp: 100
skills:
  - 1
```

¿Qué has aprendido exactamente en los ejercicios anteriores? Seleccionaste un subconjunto de un marco de datos (`planets_df`) en función de si se cumplía o no una determinada condición (anillos o no anillos), y conseguiste extraer todos los datos relevantes. ¡Impresionante! A estas alturas, es probable que la NASA ya esté coqueteando con tu CV ;-). 

Ahora, subamos un nivel y utilicemos la función `subset()`. Deberías ver la función `subset()` como un atajo para hacer exactamente lo mismo que hiciste en los ejercicios anteriores. 

```
subset(my_df, subset = some_condition)
``` 

El primer argumento de `subset()` especifica el conjunto de datos del que quieres un subconjunto. Al añadir el segundo argumento, das a R la información y las condiciones necesarias para seleccionar el subconjunto correcto. 

El código siguiente dará exactamente el mismo resultado que obtuviste en el ejercicio anterior, pero esta vez, ¡no necesitabas el `rings_vector`!

```
subset(planets_df, subset = rings)
```

`@instructions`
Utiliza `subset()` en `planets_df` para seleccionar planetas que tengan un diámetro inferior al de la Tierra. Como la variable `diameter` es una medida relativa del diámetro del planeta respecto al de la Tierra, tu condición es `diameter < 1`.

`@hint`
`subset(planets_df, subset = ...)` casi lo resuelve; ¿puedes rellenar el `...`?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# planets_df is pre-loaded in your workspace

# Select planets with diameter < 1

```

`@solution`
```{r}
# planets_df is pre-loaded in your workspace

# Select planets with diameter < 1
subset(planets_df, subset = diameter < 1)
```

`@sct`
```{r}
msg = "¡No elimines ni sobrescribas el data frame `planets_df`!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex()  %>% check_correct({
  ex() %>% check_output_expr("subset(planets_df, subset = diameter < 1)", missing_msg = "¿Has especificado correctamente la parte `subset = ...` dentro de `subset()`? La condición en este caso es `diameter < 1`. Simplemente imprime el resultado.")  

}, {
  ex() %>% check_function("subset") %>% check_arg('x') %>% check_equal(incorrect_msg = "El primer argumento que pasas a `subset()` debería ser `planets_df`.")

})
success_msg("¡Genial! No solo es la función `subset()` más concisa, probablemente también es más comprensible para las personas que leen tu código. Continúa con el siguiente ejercicio.");
```

---

## Clasificación

```yaml
type: NormalExercise
key: 6a6fe74d3917c37380f7ac616ce084aa7814fb8a
xp: 100
skills:
  - 1
```

Hacer y crear clasificaciones es uno de los asuntos favoritos de la humanidad. Estas clasificaciones pueden ser útiles (las mejores universidades del mundo), entretenidas (las estrellas de cine más influyentes) o inútiles (el mejor parecido a 007).

En el análisis de datos puedes ordenar tus datos según una determinada variable del conjunto de datos. En R, esto se hace con ayuda de la función `order()`. 

`order()` es una función que te da la posición ordenada de cada elemento cuando se aplica sobre una variable, como un vector, por ejemplo:

```
a <- c(100, 10, 1000)
order(a)
[1] 2 1 3
```

10, que es el segundo elemento de `a`, es el elemento más pequeño, por lo que 2 aparece primero en la salida de `order(a)`. 100, que es el primer elemento de `a` es el segundo elemento más pequeño, por lo que 1 aparece en segundo lugar en la salida de `order(a)`.

Esto significa que podemos utilizar la salida de `order(a)` para reorganizar `a`:

    

```
a[order(a)]
[1]   10  100 1000
```

`@instructions`
Experimenta con la función `order()` de la consola. Envía la respuesta cuando estés preparado para continuar.

`@hint`
Solo tienes que jugar con la función `order()` de la consola.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Play around with the order function in the console
```

`@solution`
```{r}
# Play around with the order function in the console
```

`@sct`
```{r}
success_msg("¡Genial! Ahora usemos la función `order()` para ordenar tu marco de datos.")
```

---

## Ordenar tu marco de datos

```yaml
type: NormalExercise
key: fa88b58bf2cf62e0c181dfdcbdd2e1ddeac66807
xp: 100
skills:
  - 1
```

Muy bien, ahora que entiendes la función `order()`, vamos a hacer algo útil con ella. Te gustaría reordenar tu marco de datos de forma que empiece con el planeta más pequeño y termine con el más grande. Ordena la columna `diameter`.

`@instructions`
- Llama a `order()` en `planets_df$diameter` (la columna `diameter` de `planets_df`). Guarda el resultado como `positions`.
- Ahora reorganiza `planets_df` con el vector `positions` como índices de fila dentro de corchetes. Conserva todas las columnas. Solo tienes que imprimir el resultado.

`@hint`
- Utiliza `order(planets_df$diameter)` para crear `positions`.
- Ahora, puedes utilizar `positions` entre corchetes: `planets_df[...]`; ¿puedes rellenar el `...`?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# planets_df is pre-loaded in your workspace

# Use order() to create positions
positions <-  

# Use positions to sort planets_df

```

`@solution`
```{r}
# planets_df is pre-loaded in your workspace

# Use order() to create positions
positions <- order(planets_df$diameter)

# Use positions to sort planets_df
planets_df[positions, ]
```

`@sct`
```{r}
msg = "¡No elimines ni sobrescribas el data frame `planets_df`!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("positions") %>% check_equal(incorrect_msg = "¿Has calculado correctamente la variable `positions`? Puedes usar `order(planets_df$diameter)`.")

ex() %>% check_output_expr("planets_df[positions,]",missing_msg = "Usa `planets_df[positions, ]` para ordenar `planets_df`; ¡la coma dentro de los corchetes es crucial!")

success_msg("¡Maravilloso! Este ejercicio concluye el capítulo sobre data frames. Recuerda que los data frames son extremadamente importantes en R, los necesitarás todo el tiempo. Otra estructura de datos que se usa muy a menudo es la lista. ¡Este será el tema del próximo capítulo!")
```
