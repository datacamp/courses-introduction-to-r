---
title_meta: Hoofdstuk 5
title: Data frames
description: >-
  De meeste gegevenssets waar je mee werkt, zijn opgeslagen als data frames. Aan
  het einde van dit hoofdstuk kun je een data frame maken, interessante delen
  uit een data frame selecteren en een data frame sorteren op basis van bepaalde
  variabelen.
---

## Wat is een data frame?

```yaml
type: NormalExercise
key: 7f95849020a2563168920409022ce7bed20835b5
xp: 100
skills:
  - 1
```

Je herinnert je misschien uit het hoofdstuk over matrices dat alle elementen die je in een matrix zet van hetzelfde type moeten zijn. Toen bevatte je Star Wars-gegevensset alleen numerieke elementen.

Bij marktonderzoek heb je echter vaak vragen zoals:

- ‘Ben je getrouwd?’ of ja/nee-vragen (`logical`)
- ‘Hoe oud ben je?’ (`numeric`)
- ‘Wat is je mening over dit product?’ of andere ‘open’ vragen (`character`)
- ...

De uitkomst, namelijk de antwoorden van respondenten op de bovenstaande vragen, is een gegevensset met verschillende gegevenstypen. Je werkt vaak met gegevenssets die verschillende typen bevatten in plaats van slechts één.

Een data frame bevat de variabelen van een gegevensset als kolommen en de observaties als rijen. Dit zal bekend klinken voor wie met andere statistische softwarepakketten zoals SAS of SPSS heeft gewerkt.

`@instructions`
Verzend het antwoord. De gegevens uit het ingebouwde voorbeeld-data frame `mtcars` worden naar de console geprint.

`@hint`
Verzend het antwoord en zie wat er gebeurt!

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Print out built-in R data frame
mtcars 
```

`@solution`
```{r}
# Print out built-in R data frame
mtcars 
```

`@sct`
```{r}
ex() %>% check_output_expr("mtcars", missing_msg = "Verander niets aan de code, zorg ervoor dat je `mtcars` uitvoert.")

success_msg("Geweldig! Ga door naar de volgende oefening.")
```

---

## Snel even naar je gegevensset kijken

```yaml
type: NormalExercise
key: 3d0e64ecf5f69521ee538ecc713caa02b8b0ec46
xp: 100
skills:
  - 1
```

Wow, dat zijn veel auto's!

Werken met grote gegevenssets komt vaak voor in data-analyse. Als je met (extreem) grote gegevenssets en data frames werkt, is het je eerste taak als data-analist om een duidelijk beeld te krijgen van de structuur en de belangrijkste onderdelen. Daarom is het vaak handig om slechts een klein deel van de volledige gegevensset te bekijken.

Hoe doe je dat in R? Met de functie `head()` kun je de eerste observaties van een data frame bekijken. Op dezelfde manier geeft de functie `tail()` de laatste observaties in je gegevensset weer.

Zowel `head()` als `tail()` printen een bovenste regel, de 'header', met de namen van de verschillende variabelen in je gegevensset.

`@instructions`
Roep `head()` aan op de `mtcars`-gegevensset om de header en de eerste observaties te bekijken.

`@hint`
`head(mtcars)` toont de eerste observaties van het data frame `mtcars`.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Call head() on mtcars

```

`@solution`
```{r}
# Call head() on mtcars
head(mtcars)
```

`@sct`
```{r}
ex() %>% check_function("head") %>% check_arg('x') %>% check_equal(incorrect_msg = "Heb je `mtcars` correct doorgegeven aan de `head()` functie?")

ex() %>% check_output_expr("head(mtcars)", missing_msg = "Print gewoon het resultaat van de `head()` aanroep, het is niet nodig om het aan een nieuwe variabele toe te wijzen.")

success_msg("Geweldig! Dus, wat hebben we in deze dataset? Bijvoorbeeld, `hp` staat voor het aantal pk van de auto; de Datsun heeft het laagste aantal pk van de 6 auto's die worden weergegeven. Voor een volledig overzicht van de betekenis van de variabelen, typ `?mtcars` in de console en lees de help-pagina. Ga door naar de volgende oefening!");
```

---

## Bekijk de structuur

```yaml
type: NormalExercise
key: f4d5b1a2c4aef31645fc7e3505e699fb6e48f3e6
xp: 100
skills:
  - 1
```

Een andere methode die vaak wordt gebruikt om snel een overzicht van je data te krijgen, is de functie `str()`. De functie `str()` laat je de structuur van je gegevensset zien. Voor een data frame vertelt die je:

- Het totale aantal observaties (bijv. 32 soorten auto's)
- Het totale aantal variabelen (bijv. 11 autokenmerken)
- Een volledige lijst met de variabelennamen (bijv. `mpg`, `cyl` ... )
- Het datatype van elke variabele (bijv. `num`)
- De eerste observaties

De `str()`-functie toepassen, is vaak het eerste wat je doet wanneer je een nieuwe gegevensset of een nieuw data frame krijgt. Het is een uitstekende manier om meer inzicht te krijgen in je gegevensset voordat je met de echte analyse begint.

`@instructions`
Onderzoek de structuur van `mtcars`. Controleer of je dezelfde aantallen, variabelen en datatypen ziet als hierboven genoemd.

`@hint`
Gebruik de functie `str()` voor `mtcars`.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Investigate the structure of mtcars

```

`@solution`
```{r}
# Investigate the structure of mtcars
str(mtcars)
```

`@sct`
```{r}
ex() %>% check_output_expr("str(mtcars)", missing_msg = "Heb je `str()` correct aangeroepen op `mtcars`?")

success_msg("Goed gedaan! Je kunt veel informatie vinden door de `str()` van een dataset te bekijken. Ga door naar de volgende oefening.")
```

---

## Een data frame maken

```yaml
type: NormalExercise
key: df0b89706d90526b3c0bbe15e400b74cbd900704
xp: 100
skills:
  - 1
```

Omdat werken met ingebouwde gegevenssets lang niet zo leuk is als je eigen gegevenssets maken, werk je in de rest van dit hoofdstuk met je eigen samengestelde gegevensset. Pak je jetpack erbij, want we gaan de ruimte verkennen!

Het eerste doel is om een data frame samen te stellen met de belangrijkste kenmerken van acht planeten in ons zonnestelsel. Volgens je goede vriend Buzz zijn de belangrijkste eigenschappen van een planeet:

- Het type planeet (Terrestrial of Gas Giant).
- De diameter van de planeet ten opzichte van die van de aarde.
- De omlooptijd rond de zon ten opzichte van die van de aarde.
- Of de planeet ringen heeft of niet (TRUE of FALSE).

Na grondig onderzoek op [Wikipedia](https://en.wikipedia.org/wiki/Planet) voel je je zeker genoeg om de benodigde vectoren te maken: `name`, `type`, `diameter`, `rotation` en `rings`; deze vectoren staan al voor je in de editor. Het eerste element in elk van deze vectoren komt overeen met de eerste observatie.

Je maakt een data frame met de functie `data.frame()`. Als argumenten geef je de vectoren van hierboven door: die vormen de verschillende kolommen van je data frame. Omdat elke kolom even lang is, moeten de doorgegeven vectoren ook dezelfde lengte hebben. Vergeet niet dat het mogelijk (en waarschijnlijk) is dat ze verschillende soorten gegevens bevatten.

`@instructions`
Gebruik de functie `data.frame()` om een data frame te maken. Geef de vectoren `name`, `type`, `diameter`, `rotation` en `rings` in deze volgorde als argumenten door aan `data.frame()`. Noem het resulterende data frame `planets_df`.

`@hint`
Je `data.frame()`-aanroep begint als volgt:
```
data.frame(planets, type, diameter)
```
Kun je 'm afmaken?

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03, 
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <-

```

`@solution`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sct`
```{r}
msg = "Verander niets aan de definitie van de vectoren. Voeg alleen een `data.frame()`-aanroep toe om `planets_df` te maken."
ex() %>% check_object("name", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("type", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("diameter", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rotation", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rings", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("planets_df") %>% check_equal(incorrect_msg = "Heb je `data.frame()` correct aangeroepen om `planets_df` te maken? Zorg ervoor dat je binnen `data.frame()` alle vectoren in de juiste volgorde doorgeeft: `name`, `type`, `diameter`, `rotation` en tot slot `rings`.")

success_msg("Goed gedaan! De logische volgende stap, zoals je inmiddels weet, is het inspecteren van het data frame dat je zojuist hebt gemaakt. Ga verder naar de volgende oefening.")
```

---

## Een data frame maken (2)

```yaml
type: NormalExercise
key: c13ea421dd078030a225f49e53a8927ce8fefbe0
xp: 100
skills:
  - 1
```

Het data frame `planets_df` bevat 8 observaties en 5 variabelen. Het is beschikbaar gemaakt in de werkomgeving, dus je kunt het direct gebruiken.

`@instructions`
Gebruik `str()` om de structuur van de nieuwe variabele `planets_df` te onderzoeken.

`@hint`
`planets_df` is al beschikbaar in je werkomgeving, dus `str(planets_df)` is voldoende.

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# Check the structure of planets_df
```

`@solution`
```{r}
# Check the structure of planets_df
str(planets_df)
```

`@sct`
```{r}
msg = "Verwijder of overschrijf het `planets_df` data frame dat al beschikbaar is in de werkruimte niet!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr("str(planets_df)", missing_msg = "Heb je de structuur van `planets_df` correct weergegeven? Gebruik `str()` om dit te doen!")

success_msg("Geweldig! Nu je een duidelijk begrip hebt van de `planets_df` dataset, is het tijd om te zien hoe je elementen eruit kunt selecteren. Leer er alles over in de volgende oefeningen!")
```

---

## Selectie van data frame-elementen

```yaml
type: NormalExercise
key: 8c664726b8a173cda730cbb20a52ac1795d9a0e9
xp: 100
skills:
  - 1
```

Net als bij vectors en matrices selecteer je elementen uit een data frame met behulp van vierkante haken `[ ]`. Met een komma kun je aangeven wat je respectievelijk uit de rijen en de kolommen wilt selecteren. Bijvoorbeeld:

- `my_df[1,2]` selecteert de waarde op de eerste rij en de tweede kolom in `my_df`.
- `my_df[1:3,2:4]` selecteert rijen 1, 2, 3 en kolommen 2, 3, 4 in `my_df`.

Soms wil je alle elementen van een rij of kolom selecteren. Bijvoorbeeld, `my_df[1, ]` selecteert alle elementen van de eerste rij. Laten we deze techniek nu toepassen op `planets_df`!

`@instructions`
- Selecteer de diameter van Mercurius uit `planets_df`: dit is de waarde op de eerste rij en de derde kolom. Print het resultaat.
- Selecteer alle gegevens over Mars uit `planets_df` (de vierde rij). Print het resultaat.

`@hint`
Om de diameter voor Venus (de tweede rij) te selecteren, heb je `planets_df[2,3]` nodig. Wat heb je dan nodig voor Mercurius?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Print out diameter of Mercury (row 1, column 3)


# Print out data for Mars (entire fourth row)

```

`@solution`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Print out diameter of Mercury (row 1, column 3)
planets_df[1,3]

# Print out data for Mars (entire fourth row)
planets_df[4, ]
```

`@sct`
```{r}
msg = "Verwijder of overschrijf het `planets_df` data frame niet!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr("planets_df[1,3]", missing_msg = "Heb je de diameter voor Mercurius correct geselecteerd en afgedrukt? Je kunt `[1,3]` gebruiken.")

ex() %>% check_output_expr("planets_df[4, ]", missing_msg = "Heb je alle gegevens voor Mars correct geselecteerd en afgedrukt? Je kunt `[4,]` gebruiken.")

success_msg("Geweldig! Naast het selecteren van elementen uit je data frame op index, kun je ook de kolomnamen gebruiken. Om te leren hoe, ga naar de volgende oefening.")
```

---

## Selectie van data frame-elementen (2)

```yaml
type: NormalExercise
key: faf104fb0c605fd89f048648a4a588200bc89c76
xp: 100
skills:
  - 1
```

In plaats van getallen te gebruiken om elementen van een data frame te selecteren, kun je ook variabelenamen gebruiken om kolommen van een data frame te selecteren.

Stel dat je de eerste drie elementen van de kolom `type` wilt selecteren. Eén manier om dit te doen is

```
planets_df[1:3,2]
```

Een mogelijk nadeel van deze aanpak is dat je het kolomnummer van `type` moet weten (of opzoeken), wat lastig wordt als je veel variabelen hebt. Het is vaak makkelijker om gewoon de variabelenaam te gebruiken:

```
planets_df[1:3,"type"]
```

`@instructions`
Selecteer en print de eerste 5 waarden in de kolom `"diameter"` van `planets_df`.

`@hint`
Je kunt de eerste vijf waarden selecteren met `planets_df[1:5, ...]`. Kun je het `...`-gedeelte invullen om alleen de kolom `"diameter"` te selecteren?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Select first 5 values of diameter column

```

`@solution`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Select first 5 values of diameter column
planets_df[1:5, "diameter"]
```

`@sct`
```{r}
msg = "Verwijder of overschrijf de `planets_df` data frame niet!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr("planets_df[1:5, \"diameter\"]", missing_msg = "Heb je de eerste vijf waarden van de diameterkolom correct geselecteerd en afgedrukt? Je kunt hier `[1:5, \"diameter\"]` gebruiken.")

success_msg("Mooi! Ga door naar de volgende oefening!")
```

---

## Alleen planeten met ringen

```yaml
type: NormalExercise
key: e550ecb6ec45b856e6160ddfbb3d7875998e8365
xp: 100
skills:
  - 1
```

Vaak wil je een hele kolom selecteren, dus één specifieke variabele uit een data frame. Als je bijvoorbeeld alle elementen van de variabele `diameter` wilt selecteren, werken beide opties hieronder:

```
planets_df[,3]
planets_df[,"diameter"]
```

Er is echter een kortere manier. Als je kolommen namen hebben, kun je het `$`-teken gebruiken:

```
planets_df$diameter
```

`@instructions`
- Gebruik het `$`-teken om de variabele `rings` uit `planets_df` te selecteren. Sla de resulterende vector op als `rings_vector`.
- Print `rings_vector` om te controleren of het klopt.

`@hint`
`planets_df$diameter` selecteert de kolom `diameter` uit `planets_df`; wat heb je dan nodig om de kolom `rings` te selecteren?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# planets_df is pre-loaded in your workspace

# Select the rings variable from planets_df
rings_vector <- 
  
# Print out rings_vector
```

`@solution`
```{r}
# planets_df is pre-loaded in your workspace

# Select the rings variable from planets_df
rings_vector <- planets_df$rings

# Print out rings_vector
rings_vector
```

`@sct`
```{r}
msg = "Verwijder of overschrijf het `planets_df` data frame niet!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rings_vector") %>% check_equal(incorrect_msg = "Heb je de `rings` variabele correct geselecteerd uit `planets_df`? Gebruik `$rings`. Sla het resultaat op als `rings_vector`.")

ex() %>% check_output_expr("rings_vector", missing_msg = "Vergeet niet om `rings_vector` af te drukken nadat je het hebt aangemaakt!")

success_msg("Geweldig! Ga door naar de volgende oefening en ontdek nog een manier van subsetting!")
```

---

## Alleen planeten met ringen (2)

```yaml
type: NormalExercise
key: 1581bf4667477f274188f4f637ec7fdc73659651
xp: 100
skills:
  - 1
```

Je weet vast nog van de middelbare school dat sommige planeten in ons zonnestelsel ringen hebben en andere niet. Helaas kun je je hun namen niet meer herinneren. Kan R je helpen?

Als je `rings_vector` in de console typt, krijg je:

```
[1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
```

Dit betekent dat de eerste vier observaties (of planeten) geen ringen hebben (`FALSE`), maar de andere vier wel (`TRUE`). Je krijgt echter geen handig overzicht van de namen van deze planeten, hun diameter, enzovoort. Laten we proberen `rings_vector` te gebruiken om de gegevens te selecteren voor de vier planeten met ringen.

`@instructions`
De code in de editor selecteert de kolom `name` van alle planeten die ringen hebben. Pas de code aan zodat in plaats van alleen de kolom `name`, _alle_ kolommen voor planeten met ringen worden geselecteerd.

`@hint`
Onthoud dat je om _alle_ kolommen te selecteren het kolommengedeelte binnen de `[ ]` gewoon leeg laat! Dit betekent dat je `[rings_vector, ]` nodig hebt.

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)

rings_vector <- planets_df$rings
```

`@sample_code`
```{r}
# planets_df and rings_vector are pre-loaded in your workspace

# Adapt the code to select all columns for planets with rings
planets_df[rings_vector, "name"]
```

`@solution`
```{r}
# planets_df and rings_vector are pre-loaded in your workspace

# Adapt the code to select all columns for planets with rings
planets_df[rings_vector, ]
```

`@sct`
```{r}
msg <- "Verwijder of overschrijf `planets_df` of `rings_vector` niet!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rings_vector", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr('planets_df[rings_vector, ]', missing_msg = "Heb je de code correct aangepast om _alle_ kolommen te selecteren voor de planeten die ringen hebben? Je kunt `planets_df[rings_vector, ]` gebruiken. Zorg ervoor dat je de komma hier opneemt, het is cruciaal!")

success_msg("Geweldig! Dit is een nogal omslachtige oplossing. De volgende oefening leert je hoe je het op een beknoptere manier kunt doen.")
```

---

## Alleen planeten met ringen, maar dan korter

```yaml
type: NormalExercise
key: a4a8b72a74097196eb2f8a28b056987aae834565
xp: 100
skills:
  - 1
```

Wat heb je precies geleerd in de vorige oefeningen? Je selecteerde een subset uit een data frame (`planets_df`) op basis van de vraag of een bepaalde voorwaarde waar was (ringen of geen ringen), en je haalde alle relevante gegevens eruit. Best gaaf! Inmiddels flirt NASA waarschijnlijk al met je cv ;-).

Laten we nu een stapje verder gaan en de functie `subset()` gebruiken. Zie de functie `subset()` als een snelkoppeling om precies hetzelfde te doen als in de vorige oefeningen.

```
subset(my_df, subset = some_condition)
```

Het eerste argument van `subset()` geeft de gegevensset aan waarvoor je een subset wilt. Met het tweede argument geef je R de nodige informatie en voorwaarden om de juiste subset te selecteren.

De code hieronder geeft exact hetzelfde resultaat als in de vorige oefening, maar deze keer heb je de `rings_vector` niet nodig!

```
subset(planets_df, subset = rings)
```

`@instructions`
Gebruik `subset()` op `planets_df` om planeten te selecteren die een kleinere diameter hebben dan de aarde. Omdat de variabele `diameter` een relatieve maat is ten opzichte van de diameter van de aarde, is je voorwaarde `diameter < 1`.

`@hint`
Met `subset(planets_df, subset = ...)` ben je er al bijna; kun je de `...` invullen?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# planets_df is pre-loaded in your workspace

# Select planets with diameter < 1

```

`@solution`
```{r}
# planets_df is pre-loaded in your workspace

# Select planets with diameter < 1
subset(planets_df, subset = diameter < 1)
```

`@sct`
```{r}
msg = "Verwijder of overschrijf het `planets_df` data frame niet!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex()  %>% check_correct({
  ex() %>% check_output_expr("subset(planets_df, subset = diameter < 1)", missing_msg = "Heb je het `subset = ...` deel correct gespecificeerd binnen `subset()`? De voorwaarde in dit geval is `diameter < 1`. Print gewoon het resultaat uit.")  

}, {
  ex() %>% check_function("subset") %>% check_arg('x') %>% check_equal(incorrect_msg = "Het eerste argument dat je aan `subset()` doorgeeft, moet `planets_df` zijn.")

})
success_msg("Geweldig! Niet alleen is de `subset()` functie beknopter, het is waarschijnlijk ook beter te begrijpen voor mensen die je code lezen. Ga door naar de volgende oefening.");
```

---

## Sorteren

```yaml
type: NormalExercise
key: 6a6fe74d3917c37380f7ac616ce084aa7814fb8a
xp: 100
skills:
  - 1
```

Lijstjes maken en rangschikken is een van de favoriete bezigheden van de mens. Ze kunnen nuttig zijn (beste universiteiten ter wereld), vermakelijk (meest invloedrijke filmsterren) of zinloos (beste 007-lookalike).

In data-analyse kun je je gegevens sorteren op basis van een bepaalde variabele in de gegevensset. In R doe je dat met de functie `order()`.

`order()` is een functie die, toegepast op een variabele zoals een vector, de gerangschikte positie van elk element teruggeeft, bijvoorbeeld:

```
a <- c(100, 10, 1000)
order(a)
[1] 2 1 3
```

10, het tweede element in `a`, is het kleinste element, dus 2 komt als eerste in de output van `order(a)`. 100, het eerste element in `a`, is het op één na kleinste element, dus 1 komt als tweede in de output van `order(a)`.

Dit betekent dat we de output van `order(a)` kunnen gebruiken om `a` te herschikken:
    
```
a[order(a)]
[1]   10  100 1000
```

`@instructions`
Experimenteer met de functie `order()` in de console. Verzend je antwoord wanneer je klaar bent om verder te gaan.

`@hint`
Speel gewoon wat met de functie `order()` in de console!

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Play around with the order function in the console
```

`@solution`
```{r}
# Play around with the order function in the console
```

`@sct`
```{r}
success_msg("Geweldig! Laten we nu de functie `order()` gebruiken om je dataframe te sorteren!")
```

---

## Je data frame sorteren

```yaml
type: NormalExercise
key: fa88b58bf2cf62e0c181dfdcbdd2e1ddeac66807
xp: 100
skills:
  - 1
```

Oké, nu je de functie `order()` begrijpt, gaan we er iets nuttigs mee doen. Je wilt je data frame herschikken, zodat het begint met de kleinste planeet en eindigt met de grootste. Een sortering van de kolom `diameter`.

`@instructions`
- Roep `order()` aan voor `planets_df$diameter` (de kolom `diameter` van `planets_df`). Sla het resultaat op als `positions`.
- Herschik nu `planets_df` met de vector `positions` als rij-index tussen vierkante haken. Behoud alle kolommen. Print simpelweg het resultaat.

`@hint`
- Gebruik `order(planets_df$diameter)` om `positions` aan te maken.
- Nu kun je `positions` tussen vierkante haken gebruiken: `planets_df[...]`; kun je de `...` invullen?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# planets_df is pre-loaded in your workspace

# Use order() to create positions
positions <-  

# Use positions to sort planets_df

```

`@solution`
```{r}
# planets_df is pre-loaded in your workspace

# Use order() to create positions
positions <- order(planets_df$diameter)

# Use positions to sort planets_df
planets_df[positions, ]
```

`@sct`
```{r}
msg = "Verwijder of overschrijf het `planets_df` data frame niet!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("positions") %>% check_equal(incorrect_msg = "Heb je de variabele `positions` correct berekend? Je kunt `order(planets_df$diameter)` gebruiken.")

ex() %>% check_output_expr("planets_df[positions,]",missing_msg = "Gebruik `planets_df[positions, ]` om `planets_df` te sorteren; de komma binnen de vierkante haken is cruciaal!")

success_msg("Geweldig! Deze oefening sluit het hoofdstuk over data frames af. Onthoud dat data frames enorm belangrijk zijn in R, je zult ze altijd nodig hebben. Een andere veelgebruikte datastructuur is de lijst. Dit zal het onderwerp van het volgende hoofdstuk zijn!")
```
