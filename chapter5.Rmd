---
title_meta: "Kapitel\_5"
title: Dataframes
description: >-
  Die meisten Datensätze, mit denen du arbeiten wirst, werden als Dataframes
  gespeichert. Nach diesem Kapitel bist du in der Lage, Dataframes zu erstellen,
  relevante Teile von Dataframes auszuwählen und den Inhalt von Dataframes
  anhand bestimmter Variablen zu sortieren.
---

## Was sind Dataframes?

```yaml
type: NormalExercise
key: 7f95849020a2563168920409022ce7bed20835b5
xp: 100
skills:
  - 1
```

Du erinnerst dich vielleicht aus dem Kapitel über Matrizen, dass alle Elemente, die du in eine Matrix einträgst, vom selben Typ sein sollten. Damals enthielt dein Datensatz zu „Star Wars“ nur numerische Elemente. 

Bei einer Marktforschungsumfrage gibt es jedoch oft Fragen wie:

- „Sind Sie verheiratet?“ / „Ja/Nein“-Fragen (`logical`)
- „Wie alt sind Sie?“ (`numeric`)
- „Was halten Sie von diesem Produkt?“ / offene Fragen ohne Antwortvorgaben (`character`)
- ...

Das Ergebnis, nämlich die Antworten der Befragten auf die oben formulierten Fragen, ist ein Datensatz mit verschiedenen Datentypen. Du wirst oft mit Datensätzen arbeiten, die nicht nur einen, sondern verschiedene Datentypen enthalten. 

Ein Dataframe hat die Variablen eines Datensatzes als Spalten und die Beobachtungen als Zeilen.  Für diejenigen, die mit anderen statistischen Softwarepaketen wie SAS oder SPSS vertraut sind, wird dies ein vertrautes Konzept sein.

`@instructions`
Sende deine Lösung mit der zugehörigen Schaltfläche ab. Die Daten aus dem vorgefertigten Beispiel-Dataframe `mtcars` werden in der Konsole ausgegeben.

`@hint`
Sende die Antwort ab und lass dich überraschen!

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Print out built-in R data frame
mtcars 
```

`@solution`
```{r}
# Print out built-in R data frame
mtcars 
```

`@sct`
```{r}
ex() %>% check_output_expr("mtcars", missing_msg = "Ändere nichts am Code. Stelle sicher, dass du `mtcars` ausgibst.")

success_msg("Super! Weiter zum nächsten Übungsaufgabe.")
```

---

## Erste Einblicke in einen Datensatz

```yaml
type: NormalExercise
key: 3d0e64ecf5f69521ee538ecc713caa02b8b0ec46
xp: 100
skills:
  - 1
```

Wow, das sind ganz schön viele Autos! 

Die Arbeit mit großen Datensätzen ist in der Datenanalyse keine Seltenheit. Wenn du mit (extrem) großen Datensätzen und Dataframes arbeitest, besteht deine erste Aufgabe bei der Datenanalyse darin, ein Verständnis für die Struktur der Daten und die wichtigsten Elemente zu entwickeln. Deshalb ist es oft sinnvoll, nur einen kleinen Teil des gesamten Datensatzes zu betrachten. 

Wie macht man das in R? Mit der Funktion `head()` kannst du die ersten Beobachtungen eines Dataframes anzeigen. Analog dazu gibt die Funktion `tail()` die letzten Beobachtungen in deinem Datensatz aus.

Sowohl `head()` als auch `tail()` geben ganz oben eine Kopfzeile („Header“) aus, in der die Namen der Variablen in deinem Datensatz angegeben sind.

`@instructions`
Rufe `head()` für den Datensatz `mtcars` auf, um dir die Kopfzeile und die ersten Beobachtungen anzusehen.

`@hint`
`head(mtcars)` zeigt die ersten Beobachtungen im Dataframe `mtcars` an.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Call head() on mtcars

```

`@solution`
```{r}
# Call head() on mtcars
head(mtcars)
```

`@sct`
```{r}
ex() %>% check_function("head") %>% check_arg('x') %>% check_equal(incorrect_msg = "Hast du `mtcars` korrekt an die Funktion `head()` übergeben?")

ex() %>% check_output_expr("head(mtcars)", missing_msg = "Gib einfach das Ergebnis des `head()`-Aufrufs aus, es ist nicht nötig, es einer neuen Variablen zuzuweisen.")

success_msg("Wunderbar! Was haben wir in diesem Datensatz? Zum Beispiel steht `hp` für die Pferdestärke des Autos; der Datsun hat die niedrigste Pferdestärke der 6 angezeigten Autos. Für einen vollständigen Überblick über die Bedeutung der Variablen, gib `?mtcars` in die Konsole ein und lies die Hilfeseite. Weiter zur nächsten Übung!");
```

---

## Struktur eines Datensatzes

```yaml
type: NormalExercise
key: f4d5b1a2c4aef31645fc7e3505e699fb6e48f3e6
xp: 100
skills:
  - 1
```

Eine weitere Option, die oft genutzt wird, um einen schnellen Überblick über die Daten zu bekommen, ist die Funktion `str()`. Mithilfe von `str()` kannst du dir die Struktur deines Datensatzes anzeigen lassen. Für einen Dataframe liefert diese Funktion folgende Informationen:

- Gesamtzahl der Beobachtungen (z. B. 32 Fahrzeugtypen)
- Gesamtzahl der Variablen (z. B. 11 Fahrzeugmerkmale)
- Vollständige Liste der Variablennamen (z. B. `mpg`, `cyl` usw.)
- Datentyp jeder Variablen (z. B. `num`)
- Ausschnitt mit den ersten Beobachtungen

Ein Aufruf der Funktion `str()` wird oft das Erste sein, was du tust, wenn du einen neuen Datensatz oder Dataframe erhältst. Sie liefert einen guten Einblick in den Datensatz, bevor du mit der eigentlichen Analyse beginnst.

`@instructions`
Schau dir die Struktur von `mtcars` genau an. Vergewissere dich, dass du dieselben Zahlen, Variablen und Datentypen siehst, die im Text dieser Übung genannt werden.

`@hint`
Verwende die Funktion `str()` mit `mtcars`.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Investigate the structure of mtcars

```

`@solution`
```{r}
# Investigate the structure of mtcars
str(mtcars)
```

`@sct`
```{r}
ex() %>% check_output_expr("str(mtcars)", missing_msg = "Hast du `str()` korrekt auf `mtcars` angewendet?")

success_msg("Gute Arbeit! Du kannst viele Informationen erhalten, indem du die `str()` eines Datensatzes ansiehst. Weiter zur nächsten Übung.")
```

---

## Dataframes erstellen

```yaml
type: NormalExercise
key: df0b89706d90526b3c0bbe15e400b74cbd900704
xp: 100
skills:
  - 1
```

Da die Verwendung vorgefertigter Datensätze nicht einmal halb so viel Spaß macht wie das Erstellen eigener Datensätze, basiert der Rest dieses Kapitels auf einem von dir erstellten Datensatz. Jetzt schnapp dir deinen Raumanzug, denn es ist Zeit für eine Tour durch den Weltraum! 

Im ersten Schritt sollst du einen Dataframe erstellen, der die wichtigsten Eigenschaften von acht Planeten in unserem Sonnensystem beschreibt. Deinem guten Freund Buzz zufolge sind die wichtigsten Merkmale eines Planeten:

- Art des Planeten (Erdplanet oder Gasriese)
- Durchmesser des Planeten im Verhältnis zum Durchmesser der Erde
- Rotation des Planeten um die Sonne im Verhältnis zur Rotation der Erde
- Vorhandensein von Ringen um den Planeten (TRUE oder FALSE)

Nachdem du sorgfältig auf [Wikipedia](https://en.wikipedia.org/wiki/Planet) recherchiert hast, bist du dir sicher, welche Vektoren benötigt werden: `name`, `type`, `diameter`, `rotation` und `rings`. Diese Vektoren sind bereits im Editor vorbereitet. Das erste Element in jedem dieser Vektoren entspricht der ersten Beobachtung.

Du erstellst einen Dataframe mit der Funktion `data.frame()`. Als Argumente übergibst du die Vektoren von vorhin – aus ihnen entstehen die verschiedenen Spalten deines Dataframes. Da jede Spalte dieselbe Länge hat, sollten auch die von dir übergebenen Vektoren dieselbe Länge haben. Es ist allerdings möglich (und wahrscheinlich), dass sie unterschiedliche Arten von Daten enthalten.

`@instructions`
Verwende die Funktion `data.frame()`, um einen Dataframe zu erstellen. Übergib die Vektoren `name`, `type`, `diameter`, `rotation` und `rings` als Argumente an `data.frame()`, und zwar in genau dieser Reihenfolge. Nenne den resultierenden Dataframe `planets_df`.

`@hint`
Dein `data.frame()`-Aufruf beginnt wie folgt:
```
data.frame(planets, type, diameter)
```
Kannst du den Code vollenden?

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03, 
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <-

```

`@solution`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sct`
```{r}
msg = "Ändere nichts an der Definition der Vektoren. Füge nur einen `data.frame()`-Aufruf hinzu, um `planets_df` zu erstellen."
ex() %>% check_object("name", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("type", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("diameter", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rotation", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rings", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("planets_df") %>% check_equal(incorrect_msg = "Hast du `data.frame()` korrekt aufgerufen, um `planets_df` zu erstellen? Stelle sicher, dass du innerhalb von `data.frame()` alle Vektoren in der richtigen Reihenfolge übergibst: `name`, `type`, `diameter`, `rotation` und schließlich `rings`.")

success_msg("Großartig gemacht! Der logische nächste Schritt, wie du jetzt weißt, ist die Inspektion des gerade erstellten Dataframes. Gehe zur nächsten Übung über.")
```

---

## Dataframes erstellen (2)

```yaml
type: NormalExercise
key: c13ea421dd078030a225f49e53a8927ce8fefbe0
xp: 100
skills:
  - 1
```

Der Dataframe `planets_df` sollte acht Beobachtungen und fünf Variablen enthalten. Er wurde schon im Workspace hinterlegt, sodass du ihn direkt nutzen kannst.

`@instructions`
Benutze `str()`, um dir die Struktur der neuen Variablen `planets_df` anzuschauen.

`@hint`
`planets_df` ist bereits in deinem Workspace vorhanden, also sollte `str(planets_df)` funktionieren.

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# Check the structure of planets_df
```

`@solution`
```{r}
# Check the structure of planets_df
str(planets_df)
```

`@sct`
```{r}
msg = "Entferne oder überschreibe den bereits im Arbeitsbereich verfügbaren `planets_df` Dataframe nicht!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr("str(planets_df)", missing_msg = "Hast du die Struktur von `planets_df` korrekt angezeigt? Verwende `str()`, um dies zu tun!")

success_msg("Super! Jetzt, da du ein klares Verständnis des `planets_df` Datasets hast, ist es an der Zeit zu sehen, wie du Elemente daraus auswählen kannst. Erfahre alles darüber in den nächsten Übungen!")
```

---

## Dataframe-Elemente auswählen

```yaml
type: NormalExercise
key: 8c664726b8a173cda730cbb20a52ac1795d9a0e9
xp: 100
skills:
  - 1
```

Ähnlich wie bei Vektoren und Matrizen wählst du Elemente aus einem Dataframe mithilfe von eckigen Klammern aus, also `[ ]`. Durch ein Komma kannst du signalisieren, was aus den Zeilen und was aus den Spalten ausgewählt werden soll. Zum Beispiel:

- `my_df[1,2]` wählt den Wert in der ersten Zeile und zweiten Spalte in `my_df` aus.
- `my_df[1:3,2:4]` wählt die Zeilen 1, 2, 3 und die Spalten 2, 3, 4 in `my_df` aus.

Manchmal möchtest du alle Elemente einer Zeile oder Spalte auswählen. Dies geht mit der Schreibweise `my_df[1, ]` – hier werden alle Elemente der ersten Zeile ausgewählt. Nun kannst du diese Technik auf `planets_df` anwenden!

`@instructions`
- Wähle aus `planets_df` den Durchmesser vom Merkur aus: Das ist der Wert in der ersten Zeile und dritten Spalte. Gib auch dieses Ergebnis einfach aus.
- Wähle aus `planets_df` alle Daten zum Mars aus (die vierte Zeile). Gib auch dieses Ergebnis einfach aus.

`@hint`
Um den Durchmesser der Venus (zweite Zeile) auszuwählen, bräuchtest du: `planets_df[2,3]`. Wie lautet also der Code für Merkur?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Print out diameter of Mercury (row 1, column 3)


# Print out data for Mars (entire fourth row)

```

`@solution`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Print out diameter of Mercury (row 1, column 3)
planets_df[1,3]

# Print out data for Mars (entire fourth row)
planets_df[4, ]
```

`@sct`
```{r}
msg = "Entferne oder überschreibe den `planets_df` Dataframe nicht!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr("planets_df[1,3]", missing_msg = "Hast du den Durchmesser von Merkur korrekt ausgewählt und ausgegeben? Du kannst `[1,3]` verwenden.")

ex() %>% check_output_expr("planets_df[4, ]", missing_msg = "Hast du alle Daten für Mars korrekt ausgewählt und ausgegeben? Du kannst `[4,]` verwenden.")

success_msg("Super! Neben dem Auswählen von Elementen aus deinem Dataframe nach Index kannst du auch die Spaltennamen verwenden. Um zu lernen, wie das geht, gehe zur nächsten Übung.")
```

---

## Dataframe-Elemente auswählen (2)

```yaml
type: NormalExercise
key: faf104fb0c605fd89f048648a4a588200bc89c76
xp: 100
skills:
  - 1
```

Anstatt mithilfe von Zahlen Elemente eines Dataframes auszuwählen, kannst du auch die Variablennamen nutzen, um auf Spalten des Dataframes zuzugreifen. 

Angenommen, du möchtest die ersten drei Elemente der Spalte `type` auswählen. Das kannst du zum Beispiel so tun:

```
planets_df[1:3,2]
```

Bei diesem Ansatz musst du aber die Spaltennummer von `type` kennen oder nachschlagen. Das kann aufwendig werden, wenn du viele Variablen hast. Oft ist es einfacher, nur den Variablennamen zu verwenden:

```
planets_df[1:3,"type"]
```

`@instructions`
Wähle die ersten fünf Werte in der Spalte `"diameter"` von `planets_df` aus und gib sie einfach aus.

`@hint`
Du kannst die ersten fünf Werte mit `planets_df[1:5, ...]` auswählen. Kannst du den `...`-Platzhalter so ersetzen, dass nur die Spalte `"diameter"` ausgewählt wird?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Select first 5 values of diameter column

```

`@solution`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Select first 5 values of diameter column
planets_df[1:5, "diameter"]
```

`@sct`
```{r}
msg = "Entferne oder überschreibe den `planets_df` Dataframe nicht!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr("planets_df[1:5, \"diameter\"]", missing_msg = "Hast du die ersten fünf Werte aus der Spalte 'diameter' korrekt ausgewählt und ausgegeben? Du kannst hier `[1:5, \"diameter\"]` verwenden.")

success_msg("Super! Weiter zum nächsten Übungsaufgabe!")
```

---

## Ganze Spalten auswählen

```yaml
type: NormalExercise
key: e550ecb6ec45b856e6160ddfbb3d7875998e8365
xp: 100
skills:
  - 1
```

Oft möchtest du eine ganze Spalte, also eine bestimmte Variable, aus einem Dataframe auswählen. Wenn du zum Beispiel alle Elemente der Variablen `diameter` auswählen möchtest, funktionieren die beiden folgenden Optionen:

```
planets_df[,3]
planets_df[,"diameter"]
```

Es gibt jedoch eine kürzere Option. Wenn deine Spalten Namen haben, kannst du das Zeichen `$` verwenden:

```
planets_df$diameter
```

`@instructions`
- Benutze das `$`-Zeichen, um die Variable `rings` aus `planets_df` auszuwählen. Speichere den daraus resultierenden Vektor als `rings_vector`.
- Gib `rings_vector` aus, um zu sehen, ob du alles richtig gemacht hast.

`@hint`
`planets_df$diameter` wählt die Spalte `diameter` von `planets_df` aus. Welcher Code ist nötig, um die Spalte `rings` auszuwählen?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# planets_df is pre-loaded in your workspace

# Select the rings variable from planets_df
rings_vector <- 
  
# Print out rings_vector
```

`@solution`
```{r}
# planets_df is pre-loaded in your workspace

# Select the rings variable from planets_df
rings_vector <- planets_df$rings

# Print out rings_vector
rings_vector
```

`@sct`
```{r}
msg = "Entferne oder überschreibe den `planets_df` Dataframe nicht!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rings_vector") %>% check_equal(incorrect_msg = "Hast du die `rings`-Variable aus `planets_df` korrekt ausgewählt? Verwende `$rings`. Speichere das Ergebnis als `rings_vector`.")

ex() %>% check_output_expr("rings_vector", missing_msg = "Vergiss nicht, `rings_vector` auszugeben, nachdem du es erstellt hast!")

success_msg("Super! Mach weiter mit der nächsten Übung und entdecke eine weitere Möglichkeit des Subsettings!")
```

---

## Ganze Spalten auswählen (2)

```yaml
type: NormalExercise
key: 1581bf4667477f274188f4f637ec7fdc73659651
xp: 100
skills:
  - 1
```

Du weißt wahrscheinlich, dass einige Planeten in unserem Sonnensystem Ringe haben und andere nicht. Angenommen, dir fallen ihre Namen gerade nicht ein. Kann R dir helfen?

Wenn du `rings_vector` in der Konsole eingibst, erhältst du:

```
[1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
```

Das bedeutet, dass die ersten vier Beobachtungen (also Planeten) keinen Ring haben (`FALSE`), aber die anderen vier schon (`TRUE`). Allerdings bekommst du keinen schönen Überblick über die Namen dieser Planeten, ihre Durchmesser und so weiter. Versuche stattdessen, mit `rings_vector` die Daten für die vier Planeten mit Ringen auszuwählen.

`@instructions`
Der Code im Editor wählt die Spalte `name` für alle Planeten mit Ringen aus. Passe den Code so an, dass nicht nur die Spalte `name`, sondern _alle_ Spalten für Planeten mit Ringen ausgewählt werden.

`@hint`
Zur Erinnerung: Um _alle_ Spalten auszuwählen, kannst du die Spaltenangabe innerhalb von `[ ]` einfach leer lassen. Du brauchst also `[rings_vector, ]`.

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)

rings_vector <- planets_df$rings
```

`@sample_code`
```{r}
# planets_df and rings_vector are pre-loaded in your workspace

# Adapt the code to select all columns for planets with rings
planets_df[rings_vector, "name"]
```

`@solution`
```{r}
# planets_df and rings_vector are pre-loaded in your workspace

# Adapt the code to select all columns for planets with rings
planets_df[rings_vector, ]
```

`@sct`
```{r}
msg <- "Entferne oder überschreibe `planets_df` oder `rings_vector` nicht!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rings_vector", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr('planets_df[rings_vector, ]', missing_msg = "Hast du den Code korrekt angepasst, um _alle_ Spalten für die Planeten auszuwählen, die Ringe haben? Du kannst `planets_df[rings_vector, ]` verwenden. Achte darauf, das Komma hier einzufügen, es ist entscheidend!")

success_msg("Wunderbar! Das ist eine ziemlich mühsame Lösung. Die nächste Übung wird dir beibringen, wie man es auf eine prägnantere Weise macht.")
```

---

## Ganze Spalten auswählen – aber effizienter

```yaml
type: NormalExercise
key: a4a8b72a74097196eb2f8a28b056987aae834565
xp: 100
skills:
  - 1
```

Was hast du also in den vorigen Übungen gelernt? Du hast eine Teilmenge aus einem Dataframe (`planets_df`) ausgewählt, und zwar abhängig davon, ob eine bestimmte Bedingung erfüllt war oder nicht (Planet hat einen Ring oder nicht). Und du hast es geschafft, alle relevanten Daten abzurufen. Ziemlich cool! Inzwischen flirtet die NASA wahrscheinlich schon mit deinem Lebenslauf ;-). 

Nun gehst du einen Schritt weiter und verwendest die Funktion `subset()`. Diese Funktion ist quasi eine Abkürzung, um genau das zu tun, was du in den vorigen Übungen getan hast. 

```
subset(my_df, subset = some_condition)
``` 

Das erste Argument von `subset()` gibt den Datensatz an, aus dem du eine Teilmenge erstellen möchtest. Indem du das zweite Argument hinzufügst, gibst du R die notwendigen Informationen und Bedingungen, um die richtige Teilmenge auszuwählen. 

Der folgende Code liefert genau dasselbe Ergebnis wie in der vorigen Übung, nur dass du diesmal `rings_vector` nicht brauchst.

```
subset(planets_df, subset = rings)
```

`@instructions`
Benutze `subset()` mit `planets_df`, um alle Planeten auszuwählen, die einen kleineren Durchmesser als die Erde haben. Da die Variable `diameter` den Planetendurchmesser als relativen Wert im Vergleich zum Durchmesser der Erde enthält, lautet die nötige  Bedingung `diameter < 1`.

`@hint`
`subset(planets_df, subset = ...)` ist fast die Lösung. Kannst du den `...`-Platzhalter ersetzen?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# planets_df is pre-loaded in your workspace

# Select planets with diameter < 1

```

`@solution`
```{r}
# planets_df is pre-loaded in your workspace

# Select planets with diameter < 1
subset(planets_df, subset = diameter < 1)
```

`@sct`
```{r}
msg = "Entferne oder überschreibe den `planets_df` Dataframe nicht!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex()  %>% check_correct({
  ex() %>% check_output_expr("subset(planets_df, subset = diameter < 1)", missing_msg = "Hast du den `subset = ...` Teil in `subset()` korrekt angegeben? Die Bedingung in diesem Fall ist `diameter < 1`. Gib einfach das Ergebnis aus.")  

}, {
  ex() %>% check_function("subset") %>% check_arg('x') %>% check_equal(incorrect_msg = "Das erste Argument, das du an `subset()` übergibst, sollte `planets_df` sein.")

})
success_msg("Super! Die `subset()` Funktion ist nicht nur prägnanter, sondern wahrscheinlich auch verständlicher für Leute, die deinen Code lesen. Weiter zur nächsten Übung.");
```

---

## Sortieren

```yaml
type: NormalExercise
key: 6a6fe74d3917c37380f7ac616ce084aa7814fb8a
xp: 100
skills:
  - 1
```

Das Erstellen von Ranglisten ist eine der Lieblingsbeschäftigungen der Menschheit. Diese Ranglisten können nützlich sein (beste Universitäten der Welt) oder unterhaltsam (einflussreichste Filmstars) oder eher sinnlos (beste 007-Doppelgänger).

Bei der Datenanalyse kannst du deine Daten anhand einer bestimmten Variablen im Datensatz sortieren. In R geschieht dies mithilfe der Funktion `order()`. 

Wenn die Funktion `order()` auf eine Variable angewendet wird, zum Beispiel auf einen Vektor, liefert sie dir die Rangfolge der einzelnen Elemente:

```
a <- c(100, 10, 1000)
order(a)
[1] 2 1 3
```

10 ist das zweite Element in `a` und auch das kleinste. Daher steht eine 2 an der ersten Stelle in der Ausgabe von `order(a)`. 100 ist das erste Element in `a` und das zweitkleinste. Also steht eine 1 an zweiter Stelle in der Ausgabe von `order(a)`.

Das bedeutet, dass du die Ausgabe von `order(a)` verwenden kannst, um `a` neu zu ordnen:

    

```
a[order(a)]
[1]   10  100 1000
```

`@instructions`
Probiere in der Konsole selbst aus, wie die `order()`-Funktion arbeitet. Klicke auf die „Antworten“-Schaltfläche, wenn du bereit für die nächste Übung bist.

`@hint`
Experimentiere einfach mit der `order()`-Funktion in der Konsole!

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Play around with the order function in the console
```

`@solution`
```{r}
# Play around with the order function in the console
```

`@sct`
```{r}
success_msg("Super! Lass uns jetzt die Funktion `order()` verwenden, um dein DataFrame zu sortieren!")
```

---

## Dataframes sortieren

```yaml
type: NormalExercise
key: fa88b58bf2cf62e0c181dfdcbdd2e1ddeac66807
xp: 100
skills:
  - 1
```

Okay, du verstehst nun die `order()`-Funktion. Dann kannst du sie ja jetzt für etwas Nützliches einsetzen. Du möchtest deinen Dataframe neu sortieren, und zwar so, dass er mit dem kleinsten Planeten beginnt und mit dem größten endet. Es muss also anhand der Spalte `diameter` sortiert werden.

`@instructions`
- Rufe `order()` mit `planets_df$diameter` auf (d. h. die Spalte `diameter` von `planets_df`). Speichere das Ergebnis als `positions`.
- Sortiere nun die Werte von `planets_df` mit dem Vektor `positions` für den Zeilenindex in eckigen Klammern neu. Behalte alle Spalten bei. Gib auch dieses Ergebnis einfach aus.

`@hint`
- Verwende `order(planets_df$diameter)`, um `positions` zu erstellen.
- Dann solltest du `positions` in eckigen Klammern einfügen: `planets_df[...]`. Kannst du den `...`-Platzhalter ersetzen?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# planets_df is pre-loaded in your workspace

# Use order() to create positions
positions <-  

# Use positions to sort planets_df

```

`@solution`
```{r}
# planets_df is pre-loaded in your workspace

# Use order() to create positions
positions <- order(planets_df$diameter)

# Use positions to sort planets_df
planets_df[positions, ]
```

`@sct`
```{r}
msg = "Entferne oder überschreibe den `planets_df` Data Frame nicht!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("positions") %>% check_equal(incorrect_msg = "Hast du die Variable `positions` korrekt berechnet? Du kannst `order(planets_df$diameter)` verwenden.")

ex() %>% check_output_expr("planets_df[positions,]",missing_msg = "Verwende `planets_df[positions, ]`, um `planets_df` zu sortieren; das Komma innerhalb der eckigen Klammern ist entscheidend!")

success_msg("Wunderbar! Diese Übung schließt das Kapitel über Data Frames ab. Denke daran, dass Data Frames in R extrem wichtig sind, du wirst sie die ganze Zeit brauchen. Eine andere sehr oft verwendete Datenstruktur ist die Liste. Dies wird das Thema des nächsten Kapitels sein!")
```
