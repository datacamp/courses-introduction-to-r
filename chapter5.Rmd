---
title_meta: Chapitre 5
title: Trames de données
description: >-
  La plupart des ensembles de données avec lesquels vous travaillerez seront
  stockés sous forme de trames de données. À la fin de ce chapitre, vous serez
  en mesure de créer une trame de données, de sélectionner des parties
  intéressantes d'une trame de données et de classer une trame de données en
  fonction de certaines variables.
---

## Qu'est-ce qu'une trame de données ?

```yaml
type: NormalExercise
key: 7f95849020a2563168920409022ce7bed20835b5
xp: 100
skills:
  - 1
```

Vous vous souvenez peut-être depuis le chapitre sur les matrices que tous les éléments que vous placez dans une matrice doivent être du même type. À l'époque, votre ensemble de données sur Star Wars ne contenait que des éléments numériques. 

Cependant, lors de la réalisation d’une étude de marché, vous êtes souvent confronté à des questions telles que celles-ci :

- Questions « Êtes-vous marié(e) ? » ou « oui/non » (`logical`)
- Quel âge avez-vous ? » (`numeric`)
- « Quelle est votre opinion sur ce produit ? » Ou d'autres questions « ouvertes » (`character`)
- ...

Le résultat, à savoir les réponses des répondants aux questions formulées ci-dessus, est un ensemble de données de différents types. Vous aurez souvent l’occasion de travailler avec des ensembles de données qui contiennent différents types de données au lieu d'un seul. 

Une trame de données présente les variables d'un ensemble de données sous forme de colonnes et les observations sous forme de lignes. Il s'agit d'un concept familier pour ceux qui utilisent d'autres logiciels statistiques tels que SAS ou SPSS.

`@instructions`
Exécutez le code. Les données de la trame de données de l'exemple intégré `mtcars` seront affichées sur la console.

`@hint`
Exécutez le code et assistez à la magie !

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Print out built-in R data frame
mtcars 
```

`@solution`
```{r}
# Print out built-in R data frame
mtcars 
```

`@sct`
```{r}
ex() %>% check_output_expr("mtcars", missing_msg = "Ne modifiez rien dans le code, assurez-vous d'afficher `mtcars`.")

success_msg("Super ! Continuez à l'exercice suivant.")
```

---

## Rapidement, jetez un coup d'œil à votre jeu de données

```yaml
type: NormalExercise
key: 3d0e64ecf5f69521ee538ecc713caa02b8b0ec46
xp: 100
skills:
  - 1
```

Cela fait beaucoup de voitures ! 

Dans l'analyse de données, il n'est pas rare de travailler avec de grands ensembles de données. Lorsque vous travaillez avec des ensembles de données et des trames de données (extrêmement) volumineux, votre première tâche en tant qu'analyste de données est d'acquérir une compréhension claire de leur structure et de leurs principaux éléments. Il est donc souvent utile de ne montrer qu'une petite partie de l'ensemble des données. 

Comment faire cela dans R ? La fonction `head()` vous permet d'afficher les premières observations d'une trame de données. De même, la fonction `tail()` affiche les dernières observations de votre ensemble de données.

`head()` et `tail()` affichent tous deux une ligne supérieure appelée « header », qui contient les noms des différentes variables de votre ensemble de données.

`@instructions`
Appelez `head()` sur le jeu de données `mtcars` pour voir l'en-tête et les premières observations.

`@hint`
`head(mtcars)` affichera les premières observations de la base de données `mtcars`.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Call head() on mtcars

```

`@solution`
```{r}
# Call head() on mtcars
head(mtcars)
```

`@sct`
```{r}
ex() %>% check_function("head") %>% check_arg('x') %>% check_equal(incorrect_msg = "Avez-vous correctement passé `mtcars` à la fonction `head()` ?")

ex() %>% check_output_expr("head(mtcars)", missing_msg = "Affichez simplement le résultat de l'appel `head()`, il n'est pas nécessaire de l'assigner à une nouvelle variable.")

success_msg("Merveilleux ! Alors, que trouvons-nous dans cet ensemble de données ? Par exemple, `hp` représente la puissance de la voiture ; la Datsun a la plus faible puissance parmi les 6 voitures affichées. Pour un aperçu complet de la signification des variables, tapez `?mtcars` dans la console et lisez la page d'aide. Continuez à l'exercice suivant !");
```

---

## Jetez un coup d'œil à la structure

```yaml
type: NormalExercise
key: f4d5b1a2c4aef31645fc7e3505e699fb6e48f3e6
xp: 100
skills:
  - 1
```

Une autre méthode souvent utilisée pour obtenir un aperçu rapide de vos données est la fonction `str()`. La fonction `str()` vous montre la structure de votre ensemble de données. Pour une trame de données, il vous indique :

- Le nombre total d'observations (par exemple, 32 types de voitures)
- Le nombre total de variables (par exemple, 11 caractéristiques de la voiture)
- Une liste complète des noms des variables (par exemple `mpg`, `cyl`… )
- Le type de données de chaque variable (par exemple `num`)
- Les premières observations

Appliquer la fonction `str()`] est souvent la première chose à faire lorsque vous recevez un nouvel ensemble de données ou une nouvelle base de données. C'est un excellent moyen d'obtenir une meilleure compréhension de votre ensemble de données avant de passer à l'analyse proprement dite.

`@instructions`
Étudiez la structure de `mtcars`. Assurez-vous que vous voyez les mêmes nombres, variables et types de données que ceux mentionnés ci-dessus.

`@hint`
Utilisez la fonction `str()` sur `mtcars`.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Investigate the structure of mtcars

```

`@solution`
```{r}
# Investigate the structure of mtcars
str(mtcars)
```

`@sct`
```{r}
ex() %>% check_output_expr("str(mtcars)", missing_msg = "Avez-vous correctement appelé `str()` sur `mtcars`?")

success_msg("Bon travail! Vous pouvez trouver beaucoup d'informations en visualisant le `str()` d'un ensemble de données. Continuez à l'exercice suivant.")
```

---

## Création d'une trame de données

```yaml
type: NormalExercise
key: df0b89706d90526b3c0bbe15e400b74cbd900704
xp: 100
skills:
  - 1
```

Étant donné que l'utilisation des ensembles de données intégrés ne représente même pas la moitié du plaisir que procure la création de vos propres ensembles de données, le reste de ce chapitre est basé sur votre propre ensemble de données. Mettez votre jet pack car il est temps d'explorer l'espace ! 

Dans un premier temps, vous souhaitez construire une trame de données décrivant les principales caractéristiques de huit planètes de notre système solaire. Selon votre ami Buzz, les principales caractéristiques d'une planète sont les suivantes :

- Le type de planète (rocheuse ou géante gazeuse).
- Diamètre de la planète par rapport au diamètre de la Terre.
- La rotation de la planète autour du soleil par rapport à celle de la Terre.
- Si la planète a des anneaux ou non (TRUE ou FALSE).

Après avoir effectué des recherches de qualité sur [Wikipedia](https://en.wikipedia.org/wiki/Planet), vous vous sentez suffisamment en confiance pour créer les vecteurs nécessaires : `name`, `type`, `diameter`, `rotation` et `rings` ; ces vecteurs ont déjà été codés dans l'éditeur. Le premier élément de chacun de ces vecteurs correspond à la première observation.

Vous construisez une trame de données avec la fonction `data.frame()`. Comme arguments, vous passez les vecteurs cités précédemment : ils deviendront les différentes colonnes de votre trame de données. Comme chaque colonne a la même longueur, les vecteurs que vous passez doivent également avoir la même longueur. Toutefois, n'oubliez pas qu'il est possible (et probable) qu'ils contiennent des types de données différents.

`@instructions`
Utilisez la fonction `data.frame()` pour construire une trame de données. Passez les vecteurs `name`, `type`, `diameter`, `rotation` et `rings` comme arguments à `data.frame()`, dans cet ordre. Appelez la trame de données résultant `planets_df`.

`@hint`
Votre appel de `data.frame()` commence comme suit :
```
data.frame(planets, type, diameter)
```
Pouvez-vous le terminer ?

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03, 
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <-

```

`@solution`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sct`
```{r}
msg = "Ne changez rien à la définition des vecteurs. Ajoutez seulement un appel à `data.frame()` pour créer `planets_df`."
ex() %>% check_object("name", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("type", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("diameter", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rotation", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rings", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("planets_df") %>% check_equal(incorrect_msg = "Avez-vous correctement appelé `data.frame()` pour créer `planets_df` ? À l'intérieur de `data.frame()`, assurez-vous de passer tous les vecteurs dans le bon ordre : `name`, `type`, `diameter`, `rotation` et enfin `rings`.")

success_msg("Bon travail ! La prochaine étape logique, comme vous le savez maintenant, est d'inspecter le tableau de données que vous venez de créer. Passez à l'exercice suivant.")
```

---

## Création d'une trame de données (2)

```yaml
type: NormalExercise
key: c13ea421dd078030a225f49e53a8927ce8fefbe0
xp: 100
skills:
  - 1
```

La base de données `planets_df` doit comporter 8 observations et 5 variables. Il a été mis à disposition dans l'espace de travail, pour que vous puissiez l'utiliser directement.

`@instructions`
Utilisez `str()` pour étudier la structure de la nouvelle variable `planets_df`.

`@hint`
`planets_df` est déjà disponible dans votre espace de travail. `str(planets_df)` fera l'affaire.

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# Check the structure of planets_df
```

`@solution`
```{r}
# Check the structure of planets_df
str(planets_df)
```

`@sct`
```{r}
msg = "Ne supprimez pas et ne remplacez pas le cadre de données `planets_df` qui est déjà disponible dans l'espace de travail !"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr("str(planets_df)", missing_msg = "Avez-vous correctement affiché la structure de `planets_df` ? Utilisez `str()` pour le faire !")

success_msg("Génial ! Maintenant que vous avez une compréhension claire du jeu de données `planets_df`, il est temps de voir comment vous pouvez sélectionner des éléments à partir de celui-ci. Apprenez tout à ce sujet dans les prochains exercices !")
```

---

## Sélection des éléments de la trame de données

```yaml
type: NormalExercise
key: 8c664726b8a173cda730cbb20a52ac1795d9a0e9
xp: 100
skills:
  - 1
```

Comme pour les vecteurs et les matrices, vous sélectionnez des éléments dans une trame de données à l'aide de crochets `[ ]`. En utilisant une virgule, vous pouvez indiquer ce qu'il faut sélectionner dans les lignes et les colonnes respectivement. Par exemple :

- `my_df[1,2]` sélectionne la valeur de la première ligne et de la deuxième colonne de `my_df`.
- `my_df[1:3,2:4]` sélectionne les lignes 1, 2, 3 et les colonnes 2, 3, 4 dans `my_df`.

Vous souhaitez parfois sélectionner tous les éléments d'une ligne ou d'une colonne. Par exemple, `my_df[1, ]` sélectionne tous les éléments de la première ligne. Appliquons maintenant cette technique à `planets_df`.

`@instructions`
- Dans `planets_df`, sélectionnez le diamètre de Mercure : c'est la valeur à la première ligne et à la troisième colonne. Il suffit d'afficher le résultat.
- Dans `planets_df`, sélectionnez toutes les données relatives à Mars (quatrième ligne). Il suffit d'afficher le résultat.

`@hint`
Pour sélectionner le diamètre de Vénus (deuxième rangée), vous aurez besoin de : `planets_df[2,3]`. De quoi avez-vous besoin pour Mercure ?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Print out diameter of Mercury (row 1, column 3)


# Print out data for Mars (entire fourth row)

```

`@solution`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Print out diameter of Mercury (row 1, column 3)
planets_df[1,3]

# Print out data for Mars (entire fourth row)
planets_df[4, ]
```

`@sct`
```{r}
msg = "Ne supprimez pas et ne remplacez pas la trame de données `planets_df` !"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr("planets_df[1,3]", missing_msg = "Avez-vous correctement sélectionné et imprimé le diamètre de Mercure ? Vous pouvez utiliser `[1,3]`.")

ex() %>% check_output_expr("planets_df[4, ]", missing_msg = "Avez-vous correctement sélectionné et imprimé toutes les données pour Mars ? Vous pouvez utiliser `[4,]`.")

success_msg("Super ! En plus de sélectionner des éléments de votre trame de données par index, vous pouvez également utiliser les noms de colonnes. Pour apprendre comment, passez à l'exercice suivant.")
```

---

## Sélection des éléments de la trame de données (2)

```yaml
type: NormalExercise
key: faf104fb0c605fd89f048648a4a588200bc89c76
xp: 100
skills:
  - 1
```

Au lieu d'utiliser des chiffres pour sélectionner des éléments d'une trame de données, vous pouvez également utiliser les noms de variables pour sélectionner des colonnes d'une trame de données. 

Supposons que vous souhaitiez sélectionner les trois premiers éléments de la colonne `type`. Pour ce faire, vous pouvez notamment écrire

```
planets_df[1:3,2]
```

Cette approche présente un inconvénient : il faut connaître (ou rechercher) le numéro de colonne de `type`, ce qui devient difficile si vous avez beaucoup de variables. Il est souvent plus facile d'utiliser le nom de la variable :

```
planets_df[1:3,"type"]
```

`@instructions`
Sélectionnez et affichez les 5 premières valeurs de la colonne `"diameter"` de `planets_df`.

`@hint`
Vous pouvez sélectionner les cinq premières valeurs à l'aide de `planets_df[1:5, ...]`. Pouvez-vous compléter la partie `...` pour ne sélectionner que la colonne `"diameter"` ?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Select first 5 values of diameter column

```

`@solution`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Select first 5 values of diameter column
planets_df[1:5, "diameter"]
```

`@sct`
```{r}
msg = "Ne supprimez pas et ne remplacez pas la trame de données `planets_df` !"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr("planets_df[1:5, \"diameter\"]", missing_msg = "Avez-vous correctement sélectionné les cinq premières valeurs de la colonne diamètre et les avez-vous imprimées ? Vous pouvez utiliser `[1:5, \"diameter\"]` ici.")

success_msg("Bien joué ! Continuez à l'exercice suivant !")
```

---

## Seulement les planètes avec des anneaux

```yaml
type: NormalExercise
key: e550ecb6ec45b856e6160ddfbb3d7875998e8365
xp: 100
skills:
  - 1
```

Vous souhaiterez souvent sélectionner une colonne entière, à savoir une variable spécifique d'une trame de données. Si vous souhaitez sélectionner tous les éléments de la variable `diameter`, par exemple, les deux méthodes feront l'affaire :

```
planets_df[,3]
planets_df[,"diameter"]
```

Il existe cependant un raccourci. Si vos colonnes ont des noms, vous pouvez utiliser le signe `$` :

```
planets_df$diameter
```

`@instructions`
- Utilisez le signe `$` pour sélectionner la variable `rings` à partir de `planets_df`. Enregistrez le vecteur qui en résulte dans `rings_vector`.
- Affichez `rings_vector` pour voir si vous avez bien compris.

`@hint`
`planets_df$diameter` sélectionne la colonne `diameter` à partir de `planets_df` ; que faut-il alors pour sélectionner la colonne `rings` ?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# planets_df is pre-loaded in your workspace

# Select the rings variable from planets_df
rings_vector <- 
  
# Print out rings_vector
```

`@solution`
```{r}
# planets_df is pre-loaded in your workspace

# Select the rings variable from planets_df
rings_vector <- planets_df$rings

# Print out rings_vector
rings_vector
```

`@sct`
```{r}
msg = "Ne supprimez pas et ne remplacez pas le cadre de données `planets_df` !"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rings_vector") %>% check_equal(incorrect_msg = "Avez-vous correctement sélectionné la variable `rings` de `planets_df` ? Utilisez `$rings`. Stockez le résultat sous `rings_vector`.")

ex() %>% check_output_expr("rings_vector", missing_msg = "N'oubliez pas d'imprimer `rings_vector` après l'avoir créé !")

success_msg("Super ! Continuez à l'exercice suivant et découvrez une autre façon de sous-ensemble !")
```

---

## Seulement les planètes avec des anneaux (2)

```yaml
type: NormalExercise
key: 1581bf4667477f274188f4f637ec7fdc73659651
xp: 100
skills:
  - 1
```

Vous vous souvenez probablement depuis le lycée que certaines planètes de notre système solaire ont des anneaux et d'autres non. Malheureusement, vous ne vous souvenez pas de leurs noms. R. pourrait-il vous aider ?

Si vous tapez `rings_vector` dans la console, vous obtenez :

```
[1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
```

Cela signifie que les quatre premières observations (ou planètes) n'ont pas d'anneaux (`FALSE`), mais que les quatre autres en ont (`TRUE`). Cependant, vous ne disposez pas d'une vue d'ensemble des noms de ces planètes, de leur diamètre, etc. Essayons d'utiliser `rings_vector` pour sélectionner les données des quatre planètes à anneaux.

`@instructions`
Le code dans l'éditeur sélectionne la colonne `name` de toutes les planètes qui ont des anneaux. Adaptez le code de manière à ce que _toutes les_ colonnes des planètes ayant des anneaux soient sélectionnées au lieu de la seule colonne `name`.

`@hint`
N'oubliez pas que pour sélectionner _toutes_ les colonnes, il vous suffit de laisser vide la partie « colonnes » à l'intérieur de `[ ]`. Cela signifie que vous aurez besoin de `[rings_vector, ]`.

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)

rings_vector <- planets_df$rings
```

`@sample_code`
```{r}
# planets_df and rings_vector are pre-loaded in your workspace

# Adapt the code to select all columns for planets with rings
planets_df[rings_vector, "name"]
```

`@solution`
```{r}
# planets_df and rings_vector are pre-loaded in your workspace

# Adapt the code to select all columns for planets with rings
planets_df[rings_vector, ]
```

`@sct`
```{r}
msg <- "Ne supprimez pas et ne remplacez pas `planets_df` ou `rings_vector` !"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rings_vector", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr('planets_df[rings_vector, ]', missing_msg = "Avez-vous correctement adapté le code pour sélectionner _toutes_ les colonnes pour les planètes qui ont des anneaux ? Vous pouvez utiliser `planets_df[rings_vector, ]`. Assurez-vous d'inclure la virgule ici, c'est crucial !")

success_msg("Merveilleux ! C'est une solution plutôt fastidieuse. Le prochain exercice vous apprendra comment le faire de manière plus concise.")
```

---

## Seulement les planètes avec des anneaux mais en plus court

```yaml
type: NormalExercise
key: a4a8b72a74097196eb2f8a28b056987aae834565
xp: 100
skills:
  - 1
```

Qu'avez-vous appris exactement dans les exercices précédents ? Vous avez sélectionné un sous-ensemble d'une trame de données (`planets_df`) en fonction de l'existence ou non d'une certaine condition (anneaux ou pas anneaux), et vous avez réussi à extraire toutes les données pertinentes. Plutôt impressionnant ! A l'heure actuelle, la NASA est probablement déjà en train de flirter avec votre CV ;-). 

Passons maintenant au niveau supérieur et utilisons la fonction `subset()`. Vous devriez voir la fonction `subset()` comme un raccourci pour faire exactement la même chose que ce que vous avez fait dans les exercices précédents. 

```
subset(my_df, subset = some_condition)
``` 

Le premier argument de `subset()` spécifie l'ensemble de données pour lequel vous souhaitez obtenir un sous-ensemble. En ajoutant le deuxième argument, vous donnez à R les informations et les conditions nécessaires pour sélectionner le bon sous-ensemble. 

Le code ci-dessous donnera exactement le même résultat que celui obtenu dans l'exercice précédent, mais cette fois-ci, vous n'avez pas besoin de `rings_vector`.

```
subset(planets_df, subset = rings)
```

`@instructions`
Utilisez `subset()` sur `planets_df` pour sélectionner les planètes dont le diamètre est inférieur à celui de la Terre. Comme la variable `diameter` est une mesure relative du diamètre de la planète par rapport à celui de la Terre, votre condition est `diameter < 1`.

`@hint`
`subset(planets_df, subset = ...)` résout presque le problème ; pouvez-vous compléter les `...` ?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# planets_df is pre-loaded in your workspace

# Select planets with diameter < 1

```

`@solution`
```{r}
# planets_df is pre-loaded in your workspace

# Select planets with diameter < 1
subset(planets_df, subset = diameter < 1)
```

`@sct`
```{r}
msg = "Ne supprimez pas et ne remplacez pas le data frame `planets_df` !"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex()  %>% check_correct({
  ex() %>% check_output_expr("subset(planets_df, subset = diameter < 1)", missing_msg = "Avez-vous correctement spécifié la partie `subset = ...` à l'intérieur de `subset()`. La condition dans ce cas est `diameter < 1`. Imprimez simplement le résultat.")  

}, {
  ex() %>% check_function("subset") %>% check_arg('x') %>% check_equal(incorrect_msg = "Le premier argument que vous passez à `subset()` doit être `planets_df`.")

})
success_msg("Super ! Non seulement la fonction `subset()` est plus concise, mais elle est probablement aussi plus compréhensible pour les personnes qui lisent votre code. Continuez à l'exercice suivant.");
```

---

## Tri

```yaml
type: NormalExercise
key: 6a6fe74d3917c37380f7ac616ce084aa7814fb8a
xp: 100
skills:
  - 1
```

Faire et créer des classements est l'une des activités préférées de l'être humain. Ces classements peuvent être utiles (les meilleures universités du monde), divertissants (les stars de cinéma les plus influentes) ou inutiles (le meilleur sosie de 007).

Dans l'analyse des données, vous pouvez trier vos données en fonction d'une certaine variable de l'ensemble de données. Dans R, cela se fait à l'aide de la fonction `order()`. 

`order()` est une fonction qui vous donne la position classée de chaque élément lorsqu'elle est appliquée sur une variable, comme un vecteur par exemple :

```
a <- c(100, 10, 1000)
order(a)
[1] 2 1 3
```

10, qui est le deuxième élément dans `a`, est le plus petit élément, donc 2 vient en premier dans la sortie de `order(a)`. 100, qui est le premier élément de `a`, est le deuxième plus petit élément, de sorte que 1 vient en deuxième position dans la sortie de `order(a)`.

Cela signifie que nous pouvons utiliser la sortie de `order(a)` pour remanier `a` :

    

```
a[order(a)]
[1]   10  100 1000
```

`@instructions`
Expérimentez la fonction `order()` dans la console. Envoyez la réponse lorsque vous voulez continuer.

`@hint`
Il suffit de jouer avec la fonction `order()` de la console !

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Play around with the order function in the console
```

`@solution`
```{r}
# Play around with the order function in the console
```

`@sct`
```{r}
success_msg("Super ! Utilisons maintenant la fonction `order()` pour trier votre data frame !")
```

---

## Trier votre trame de données

```yaml
type: NormalExercise
key: fa88b58bf2cf62e0c181dfdcbdd2e1ddeac66807
xp: 100
skills:
  - 1
```

Très bien, maintenant que vous comprenez la fonction `order()`, faisons quelque chose d'utile avec elle. Vous souhaitez réorganiser votre trame de données de manière à ce qu'elle commence par la plus petite planète et se termine par la plus grande. Un tri sur la colonne `diameter`.

`@instructions`
- Appelez `order()` sur `planets_df$diameter` (la colonne `diameter` de `planets_df`). Enregistrez le résultat en tant que `positions`.
- Maintenant, remélangez `planets_df` avec le vecteur `positions` en tant qu'index de ligne entre crochets. Conservez toutes les colonnes. Il suffit d'afficher le résultat.

`@hint`
- Utilisez `order(planets_df$diameter)` pour créer `positions`.
- Vous pouvez maintenant utiliser `positions` entre crochets : `planets_df[...]`; pouvez-vous compléter les `...` ?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# planets_df is pre-loaded in your workspace

# Use order() to create positions
positions <-  

# Use positions to sort planets_df

```

`@solution`
```{r}
# planets_df is pre-loaded in your workspace

# Use order() to create positions
positions <- order(planets_df$diameter)

# Use positions to sort planets_df
planets_df[positions, ]
```

`@sct`
```{r}
msg = "Ne supprimez pas et ne remplacez pas la trame de données `planets_df` !"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("positions") %>% check_equal(incorrect_msg = "Avez-vous correctement calculé la variable `positions` ? Vous pouvez utiliser `order(planets_df$diameter)`.")

ex() %>% check_output_expr("planets_df[positions,]",missing_msg = "Utilisez `planets_df[positions, ]` pour trier `planets_df` ; la virgule à l'intérieur des crochets est cruciale !")

success_msg("Magnifique ! Cet exercice conclut le chapitre sur les trames de données. Rappelez-vous que les trames de données sont extrêmement importantes en R, vous en aurez besoin tout le temps. Une autre structure de données très souvent utilisée est la liste. Ce sera le sujet du prochain chapitre !")
```
