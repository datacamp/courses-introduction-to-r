---
title_meta: Hoofdstuk 1
title: Inleiding tot de basis
description: >-
  Zet je eerste stappen met R. In dit hoofdstuk leer je de console gebruiken als
  rekenmachine en hoe je variabelen toewijst. Je maakt ook kennis met de
  basisdatatypen in R. Laten we beginnen.
free_preview: true
---

## Hoe het werkt

```yaml
type: NormalExercise
key: 15d729634a
xp: 100
skills:
  - 1
```

In de editor moet je R-code typen om de oefeningen op te lossen. Als je je code instuurt, wordt elke regel code door R geïnterpreteerd en uitgevoerd en krijg je een bericht of je code goed was of niet. De uitvoer van je R-code wordt in de console weergegeven.

R gebruikt het teken `#` om opmerkingen toe te voegen, zodat jij en anderen kunnen begrijpen waar de R-code over gaat. Net als op Twitter! Opmerkingen worden niet uitgevoerd als R-code, dus ze hebben geen invloed op je resultaat. Bijvoorbeeld, <span translate="no">_Bereken 3 + 4_</span> in de editor is een opmerking.

Je kunt ook R-commando's direct in de console uitvoeren. Dit is een goede manier om met R-code te experimenteren, omdat je inzending niet op juistheid wordt gecontroleerd.

`@instructions`
- In de editor staat al wat voorbeeldcode. Kun je zien welke regels echte R-code zijn en welke commentaar?
- Voeg een regel code toe die de som van 6 en 12 berekent en dien je code in.

`@hint`
Voeg gewoon een regel R-code toe die de som van 6 en 12 berekent, net zoals in de voorbeeldcode!

`@pre_exercise_code`
```{r}
# no pec

```

`@sample_code`
```{r}
# Calculate 3 + 4
3 + 4

# Calculate 6 + 12

```

`@solution`
```{r}
# Calculate 3 + 4
3 + 4

# Calculate 6 + 12
6 + 12
```

`@sct`
```{r}
ex() %>% check_output_expr("18", missing_msg = "Zorg ervoor dat je `6 + 12` op een nieuwe regel toevoegt. Begin de regel niet met een `#`, anders wordt je R-code niet uitgevoerd!")

success_msg("Geweldig! Zie je hoe de console het resultaat van de R-code die je hebt ingediend laat zien? Nu je vertrouwd bent met de interface, laten we aan de slag gaan met R!")
```

---

## Rekenen met R

```yaml
type: NormalExercise
key: 720745eda5
xp: 100
skills:
  - 1
```

In de meest eenvoudige vorm kun je R gebruiken als een gewone rekenmachine. Bekijk de volgende rekenkundige operatoren:

- Optellen: `+`
- Aftrekken: `-`
- Vermenigvuldigen: `*`
- Delen: `/`
- Machtsverheffen: `^`
- Modulo: `%%`

Bij de laatste twee is misschien wat extra uitleg nodig:

- De operator `^` verheft het getal links ervan tot de macht van het getal rechts ervan: bijvoorbeeld `3^2` is 9.
- Modulo geeft de rest van de deling van het getal links door het getal rechts, bijvoorbeeld 5 modulo 3 of `5 %% 3` is 2.

Gebruik deze kennis en volg de instructies om de oefening te maken.

`@instructions`
- Typ `2^5` in de editor om 2 tot de macht 5 te berekenen.
- Typ `28 %% 6` om 28 modulo 6 te berekenen.
- Voer de code uit en bekijk de R-output in de console.
- Zie je dat het symbool `#` wordt gebruikt om commentaar aan R-code toe te voegen?

`@hint`
Nog een voorbeeld van de modulo-operator: `9 %% 2` is gelijk aan `1`.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# An addition
5 + 5 

# A subtraction
5 - 5 

# A multiplication
3 * 5

 # A division
(5 + 5) / 2 

# Exponentiation


# Modulo

```

`@solution`
```{r}
# An addition
5 + 5

# A subtraction
5 - 5 

# A multiplication
3 * 5

 # A division
(5 + 5) / 2 

# Exponentiation
2 ^ 5

# Modulo
28 %% 6
```

`@sct`
```{r}
msg = "Verwijder de andere rekenkundige voorbeelden niet!"
ex() %>% check_output_expr("2^5", missing_msg = "Het machtsverheffingsvoorbeeld is niet correct. Schrijf `2 ^ 5` op een nieuwe regel.")

ex() %>% check_output_expr("28 %% 6", missing_msg = "Er lijkt een probleem te zijn met het modulo-voorbeeld. Schrijf `28 %% 6` op een nieuwe regel.")
success_msg("Geweldig! Ga verder naar de volgende oefening.")
```

---

## Variabelen toekennen

```yaml
type: NormalExercise
key: 5f200ffd43
xp: 100
skills:
  - 1
```

Een basisconcept in (statistisch) programmeren is een **variabele**.

Met een variabele kun je een waarde (bijv. 4) of een object (bijv. een functiebeschrijving) opslaan in R. Later kun je dan de naam van deze variabele gebruiken om eenvoudig de waarde of het object op te vragen dat erin is opgeslagen.

Je kunt de waarde 4 toekennen aan een variabele `my_var` met het commando

```
my_var <- 4
```

`@instructions`
Jij bent aan de beurt: maak de code in de editor af, zodat de waarde 42 wordt toegekend aan de variabele `x` in de editor. Verzend het antwoord. Wanneer je R vraagt om `x` te printen, verschijnt de waarde 42.

`@hint`
Kijk hoe de waarde 4 werd toegekend aan `my_var` in de opdracht van de oefening. Doe precies hetzelfde in de editor, maar ken nu 42 toe aan de variabele `x`.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Assign the value 42 to x
x <- 

# Print out the value of the variable x
x
```

`@solution`
```{r}
# Assign the value 42 to x
x <- 42

# Print out the value of the variable x
x
```

`@sct`
```{r}
ex() %>% check_object("x", undefined_msg = "Zorg ervoor dat je een variabele `x` definieert.")  %>% check_equal(incorrect_msg = "Zorg ervoor dat je de juiste waarde aan `x` toekent.")

success_msg("Goed gedaan! Heb je gemerkt dat R de waarde van een variabele niet naar de console print wanneer je de toewijzing deed? `x <- 42` genereerde geen output, omdat R ervan uitgaat dat je deze variabele in de toekomst nodig zult hebben. Anders zou je de waarde toch niet in een variabele hebben opgeslagen, toch? Ga door naar de volgende oefening!")
```

---

## Variabelen toekennen (2)

```yaml
type: NormalExercise
key: c5944b90eb
xp: 100
skills:
  - 1
```

Stel, je hebt een fruitmand met vijf appels. Als data-analist in opleiding wil je het aantal appels opslaan in een variabele met de naam `my_apples`.

`@instructions`
- Typ de volgende code in de editor: `my_apples <- 5`. Hiermee ken je de waarde 5 toe aan `my_apples`.
- Typ: `my_apples` onder de tweede opmerking. Daarmee print je de waarde van `my_apples`.
- Verzend je antwoord en bekijk de output: je ziet dat het getal 5 wordt geprint. R koppelt de variabele `my_apples` nu aan de waarde 5.

`@hint`
Onthoud dat je in R het toekenningssymbool `<-` kunt gebruiken om een getal of een object aan een variabele toe te kennen. Je kunt ook `=` gebruiken, maar `<-` heeft de voorkeur in de R-community.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Assign the value 5 to the variable my_apples


# Print out the value of the variable my_apples

```

`@solution`
```{r}
# Assign the value 5 to the variable my_apples
my_apples <- 5

# Print out the value of the variable my_apples
my_apples
```

`@sct`
```{r}
ex() %>% check_object("my_apples", undefined_msg = "Zorg ervoor dat je een variabele `my_apples` definieert.") %>% check_equal(incorrect_msg = "Zorg ervoor dat je de juiste waarde toewijst aan `my_apples`.")

ex() %>% check_output_expr("my_apples", missing_msg = "Heb je R expliciet gevraagd om de variabele `my_apples` naar de console te printen?")

success_msg("Geweldig! Ga door naar de volgende oefening!")
```

---

## Variabelen toekennen (3)

```yaml
type: NormalExercise
key: 1c1bd25045
xp: 100
skills:
  - 1
```

In elke smakelijke fruitmand horen sinaasappels, dus je besluit zes sinaasappels toe te voegen. Als data-analist is het je reflex om meteen de variabele `my_oranges` aan te maken en daar de waarde 6 aan toe te kennen. Vervolgens wil je berekenen hoeveel stuks fruit je in totaal hebt. Omdat je betekenisvolle namen aan deze waarden hebt gegeven, kun je dit nu op een duidelijke manier coderen:

```
my_apples + my_oranges
```

`@instructions`
- Ken de waarde 6 toe aan `my_oranges`.
- Tel de variabelen `my_apples` en `my_oranges` op en laat R het resultaat simpelweg printen.
- Ken het resultaat van `my_apples` plus `my_oranges` toe aan een nieuwe variabele `my_fruit`.

`@hint`
`my_fruit` is gewoon de som van `my_apples` en `my_oranges`. Je kunt de operator `+` gebruiken om ze op te tellen en `<-` om die waarde toe te kennen aan de variabele `my_fruit`.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Assign a value to the variables my_apples and my_oranges
my_apples <- 5


# Add these two variables together


# Create the variable my_fruit

```

`@solution`
```{r}
# Assign a value to the variables my_apples and my_oranges
my_apples  <- 5
my_oranges <- 6

# Add these two variables together
my_apples + my_oranges

# Create the variable my_fruit
my_fruit <- my_apples + my_oranges
```

`@sct`
```{r}
msg <- "Heb je `my_fruit <- my_apples + my_oranges` gebruikt om de variabele `my_fruit` te maken?"
ex() %>% check_object("my_apples") %>% check_equal(incorrect_msg = "Houd de regel die 5 toewijst aan `my_apples`.")

ex() %>% check_object("my_oranges") %>% check_equal(incorrect_msg = "Houd de regel die 6 toewijst aan `my_oranges`.")

ex() %>% check_output_expr("my_apples + my_oranges",missing_msg = "Zorg ervoor dat je het resultaat van het optellen van `my_apples` en `my_oranges` afdrukt. Het codevoorbeeld in de beschrijving geeft het antwoord op deze instructie al weg!")

ex() %>% check_object("my_fruit", undefined_msg = msg)  %>% check_equal(incorrect_msg = msg)
success_msg("Goed gedaan! Het grote voordeel van berekeningen met variabelen is herbruikbaarheid. Als je `my_apples` verandert naar 12 in plaats van 5 en het script opnieuw uitvoert, wordt `my_fruit` automatisch ook bijgewerkt. Ga door naar de volgende oefening.")
```

---

## Appels en sinaasappels

```yaml
type: NormalExercise
key: 915fcc7c99
xp: 100
skills:
  - 1
```

Het is algemene kennis dat je twee dingen die fundamenteel verschillend zijn, niet kunt optellen. Maar hé, dat is precies wat je net deed, toch :-)? De variabelen `my_apples` en `my_oranges` bevatten in de vorige oefening allebei een getal. De operator `+` werkt met numerieke variabelen in R. Als je echt <span translate="no">"apples"</span> en <span translate="no">"oranges"</span> zou proberen op te tellen en een tekstwaarde aan de variabele `my_oranges` zou toekennen (zie de editor), dan zou je proberen de som van een numerieke en een tekstvariabele (character) toe te kennen aan de variabele `my_fruit`. Dat kan niet.

`@instructions`
- Verzend het antwoord en lees de foutmelding. Zorg dat je begrijpt waarom dit niet werkt.
- Pas de code aan zodat R weet dat je 6 sinaasappels hebt en dus een fruitmand met 11 stuks fruit.

`@hint`
Je moet de numerieke waarde `6` toekennen aan de variabele `my_oranges` in plaats van de tekstwaarde `"six"`. Let op hoe de aanhalingstekens aangeven dat `"six"` een tekst (character) is.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Assign a value to the variable my_apples
my_apples <- 5 

# Fix the assignment of my_oranges
my_oranges <- "six" 

# Create the variable my_fruit and print it out
my_fruit <- my_apples + my_oranges 
my_fruit
```

`@solution`
```{r}
# Assign a value to the variable my_apples
my_apples <- 5  

# Fix the assignment of my_oranges
my_oranges <- 6

# Create the variable my_fruit and print it out
my_fruit <- my_apples + my_oranges 
my_fruit
```

`@sct`
```{r}
ex() %>% check_error(incorrect_msg = "Je kunt dit doen door de variabele `my_oranges` in te stellen op een numerieke waarde, niet op een string!")

ex() %>% check_object("my_apples") %>% check_equal(incorrect_msg = "Zorg ervoor dat `my_apples` nog steeds `5` bevat.")

ex() %>% check_object("my_oranges") %>% check_equal(incorrect_msg = "Zorg ervoor dat `my_oranges` gelijk is aan `6`.")

ex() %>% check_object("my_fruit") %>% check_equal(incorrect_msg = "De waarde van `my_fruit` is niet correct. Het zou 11 moeten zijn, de som van `my_apples` en `my_oranges`.")

ex() %>% check_object("my_fruit")%>% check_or(
  check_code(.,"my_fruit\\s*<-\\s*my_apples\\s*\\+\\s*my_oranges", missing_msg = "Heb je `my_fruit` gemaakt als de som van de variabelen `my_apples` en `my_oranges`?", append=F),
  check_code(.,"my_fruit\\s*<-\\s*my_oranges\\s*\\+\\s*my_apples", missing_msg = "Heb je `my_fruit` gemaakt als de som van de variabelen `my_apples` en `my_oranges`?", append=F)
 )
ex() %>% check_output_expr("my_fruit", missing_msg = "Verwijder de regel die `my_fruit` afdrukt niet.")

success_msg("Geweldig, ga zo door! Ga verder met de volgende oefening.")
```

---

## Basisdatatypen in R

```yaml
type: NormalExercise
key: 0f23107394
xp: 100
skills:
  - 1
```

R werkt met verschillende datatypen. Enkele van de basistypen om mee te beginnen, zijn:

- Decimale waarden zoals `4.5` heten **numeric**.
- Gehele getallen zoals `4` heten **integer**. Integers zijn ook numerics.
- Booleaanse waarden (`TRUE` of `FALSE`) heten **logical**.
- Tekstwaarden (strings) heten **characters**.

Let op: de aanhalingstekens in de editor geven aan dat `"some text"` een string is.

`@instructions`
Wijzig de waarde van de:

- variabele `my_numeric` naar `42`.
- variabele `my_character` naar `"universe"`. Let op: de aanhalingstekens geven aan dat `"universe"` een character is.
- variabele `my_logical` naar `FALSE`.

Let op: R is hoofdlettergevoelig!

`@hint`
Vervang de waarden in de editor door de waarden die in de oefening worden gegeven. Bijvoorbeeld: 
`my_numeric <- 42` kent de waarde 42 toe aan de variabele `my_numeric`.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Change my_numeric to be 42
my_numeric <- 42.5

# Change my_character to be "universe"
my_character <- "some text"

# Change my_logical to be FALSE
my_logical <- TRUE
```

`@solution`
```{r}
# Change my_numeric to be 42
my_numeric <- 42

# Change my_character to be "universe"
my_character <- "universe"

# Change my_logical to be FALSE
my_logical <- FALSE
```

`@sct`
```{r}
ex() %>% check_object("my_numeric") %>% check_equal(incorrect_msg = "Heb je de declaratie van `my_numeric` correct gewijzigd zodat het de waarde 42 bevat?")

ex() %>% check_object("my_character") %>% check_equal(incorrect_msg = "Heb je `my_character` correct gewijzigd naar `\"universe\"`? Vergeet de aanhalingstekens niet!")

ex() %>% check_object("my_logical") %>% check_equal(incorrect_msg = "Heb je `my_logical` correct gewijzigd naar `FALSE`? Alle letters van `FALSE` moeten met hoofdletters!")

success_msg("Goed gedaan! Ga verder met de volgende oefening.")
```

---

## Welk datatype is dat?

```yaml
type: NormalExercise
key: 99b549229d
xp: 100
skills:
  - 1
```

Weet je nog dat je een fout kreeg bij `5 + "six"` doordat de datatypes niet overeenkwamen? Zulke ongemakkelijke situaties kun je voorkomen door vooraf het datatype van een variabele te controleren. Dat doe je met de functie `class()`, zoals de code in de editor laat zien.

`@instructions`
Maak de code in de editor af en print ook de classes van `my_character` en `my_logical`.

`@hint`
De code die het datatype van `my_numeric` print staat er al; doe hetzelfde voor `my_character` en `my_logical`.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Declare variables of different types
my_numeric <- 42
my_character <- "universe"
my_logical <- FALSE 

# Check class of my_numeric
class(my_numeric)

# Check class of my_character


# Check class of my_logical

```

`@solution`
```{r}
# Declare variables of different types:
my_numeric <- 42
my_character <- "universe"
my_logical <- FALSE

# Check class of my_numeric
class(my_numeric)

# Check class of my_character
class(my_character)

# Check class of my_logical
class(my_logical)
```

`@sct`
```{r}
msg <- "Verander de declaratie van de variabelen niet!"
ex()  %>% check_object("my_numeric", undefined_msg = msg)  %>%  check_equal(incorrect_msg = msg)

ex()  %>% check_object("my_character", undefined_msg = msg)  %>%  check_equal(incorrect_msg = msg)

ex()  %>% check_object("my_logical", undefined_msg = msg)  %>%  check_equal(incorrect_msg = msg)

patt <- "Heb je `class(%1$s)` toegevoegd om het gegevenstype van `%1$s` af te drukken?"
ex() %>% check_output_expr("class(my_numeric)",missing_msg = "Verwijder de code die het type van `my_numeric` afdrukt niet.")

ex() %>% check_output_expr("class(my_character)",missing_msg = sprintf(patt, "my_character"))

ex() %>% check_output_expr("class(my_logical)",missing_msg = sprintf(patt, "my_logical"))
success_msg("Gefeliciteerd! Dit was de laatste oefening van dit hoofdstuk. Ga naar het volgende hoofdstuk om je onder te dompelen in de wereld van vectoren!")
```
